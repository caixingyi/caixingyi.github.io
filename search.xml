<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2023校赛补题</title>
      <link href="/2023/06/03/2023%E6%A0%A1%E8%B5%9B%E8%A1%A5%E9%A2%98/"/>
      <url>/2023/06/03/2023%E6%A0%A1%E8%B5%9B%E8%A1%A5%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="太菜了"><a href="#太菜了" class="headerlink" title="太菜了"></a>太菜了</h1><h1 id="考完试再补"><a href="#考完试再补" class="headerlink" title="考完试再补"></a>考完试再补</h1><h1 id="算是耻辱的一次比赛，都说知耻后勇，希望自己也能努力训练吧，说到底菜是原罪。"><a href="#算是耻辱的一次比赛，都说知耻后勇，希望自己也能努力训练吧，说到底菜是原罪。" class="headerlink" title="算是耻辱的一次比赛，都说知耻后勇，希望自己也能努力训练吧，说到底菜是原罪。"></a>算是耻辱的一次比赛，都说知耻后勇，希望自己也能努力训练吧，说到底菜是原罪。</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO系统</title>
      <link href="/2023/05/29/IO%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/05/29/IO%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>IO系统这一章主要讲的就是IO的四种控制方式，首先对这四种方式进行一个简单介绍，下面再对着四种方式分别进行介绍。</p><blockquote><p>程序查询方式：由cpu通过程序不断查询IO设备是否已经做好准备，从而控制IO设备于主机进行信息交换<br>程序中断方式：只在IO设备准备就绪并想cpu发出中断请求时才予以响应<br>DMA方式：主存和IO设备之间有一条直接数据通路，当主存和IO设备交换信息时，无需调用中断服务程序<br>通道方式：在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行IO命令时，只需启动有关通道，通道将执行通道程序，从而完成IO操作</p></blockquote><h1 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h1><p>IO接口时主机和外设之间的交接界面，通过接口实现主机和外设之间的信息交换</p><h1 id="IO接口的功能"><a href="#IO接口的功能" class="headerlink" title="IO接口的功能"></a>IO接口的功能</h1><p>1、进行地址译码和设备选择<br>2、实现主机和外设的通信联络控制<br>3、实现数据缓冲<br>4、信号格式的转换<br>5、传送控制命令和状态信息</p><h1 id="IO接口的基本结构"><a href="#IO接口的基本结构" class="headerlink" title="IO接口的基本结构"></a>IO接口的基本结构</h1><p>IO接口是由若干端口加上控制逻辑组成的，（端口是指可读可写的寄存器）</p><h1 id="IO接口的编址"><a href="#IO接口的编址" class="headerlink" title="IO接口的编址"></a>IO接口的编址</h1><p>1、统一编制：和内存单元一起进行编址，好处是可以用访问内存的指令访问接口，不需要专门的IO指令，缺点是减少的内存的可用空间并且速度比较慢<br><img src="https://s2.loli.net/2023/05/29/XDtqbmYe2KAxuMz.png" alt="1.png"><br>2、独立编址：IO的地址空间和主存的地址空间独立，需要设置单独的IO指令<br><img src="https://s2.loli.net/2023/05/29/nYaURfGpVFjisyI.png" alt="2.png"></p><h1 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h1><p>主要结构：<br>主要包括三大部分：设备选择器、数据缓冲器、设备状态标志<br><img src="https://s2.loli.net/2023/05/29/zZ7F3fehHR9DkVj.png" alt="3.png"><br>工作流程：<br><img src="https://s2.loli.net/2023/05/29/aYs48I65pkqKCrb.png" alt="4.png"><br>优缺点：<br><img src="https://s2.loli.net/2023/05/29/N276SAaRvoiYXh3.png" alt="5.png"><br><img src="https://s2.loli.net/2023/05/29/mUNbMqukHwBCAGn.png" alt="6.png"></p><h1 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h1><p>中断是程序在执行过程中被内部或者外部打断，转而去执行一段事先已经安排好的中断服务程序，当中断服务程序执行完接着返回断点继续执行该程序的过程<br><img src="https://s2.loli.net/2023/05/29/Fng7M4ryPZmc2Xf.png" alt="7.png"><br><img src="https://s2.loli.net/2023/05/29/yDfm6X7i8YSvaQG.png" alt="8.png"><br>中断处理方式<br><img src="https://s2.loli.net/2023/05/29/6Vlfsg3WP8HwYyk.png" alt="1.png"><br>中断响应的时间是每条指令结束后<br>如何关中断：<br>cpu内部设置由中断屏蔽触发器可以置零或置1，只有在中断触发屏蔽器标志为0时才可以开关中断<br>中断向量：中断服务程序入口地址</p><h1 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h1><p>在内存和IO设备间高速交换批量数据而设置的，完全由硬件执行，DMA完全从cpu接管总线的控制权，数据交换不再经过cpu而是直接通过总线在内存和IO设备之间进行<br><img src="https://s2.loli.net/2023/05/29/xEeXwkG2Wf4cRKa.png" alt="2.png"><br>DMA的优点<br><img src="https://s2.loli.net/2023/05/29/bDNzq8rukHTX5WZ.png" alt="3.png"><br>DMA能进行的操作<br><img src="https://s2.loli.net/2023/05/29/zRuwZSaFVHpXerl.png" alt="4.png"><br>DMA的响应：<br>1、外设向DMA发出请求<br>2、DMA向cpu发出总线请求<br>3、cpu在总线周期结束后处理DMA发来的请求，并将总线的控制权移交DMA<br>4、DMA向外设发出准备好的信号<br><img src="https://s2.loli.net/2023/05/29/hrHop1JbK9kwVul.png" alt="5.png"><br>在上面的处理方式中其实还有一个问题就是cpu放弃总线的控制权之后，IO和cpu并行工作，当cpu再次需要访存时，这时可能就发生冲突，这就需要解决这个问题<br><img src="https://s2.loli.net/2023/05/29/Nk7qHcbuKpXnRiz.png" alt="6.png"><br>停止cpu访问内存方法<br><img src="https://s2.loli.net/2023/05/29/FyNzjfiYgK3d8eP.png" alt="7.png"><br><img src="https://s2.loli.net/2023/05/29/IVJT5zKRSOxyULY.png" alt="9.png"><br>周期挪用<br><img src="https://s2.loli.net/2023/05/29/IAl15rskeEB6nzM.png" alt="10.png"><br><img src="https://s2.loli.net/2023/05/29/KaO1QTYu4xEdbSm.png" alt="11.png"><br><img src="https://s2.loli.net/2023/05/29/hdmBcNuCiVSFfZL.png" alt="12.png"><br>交替访内<br><img src="https://s2.loli.net/2023/05/29/omPThQGS4LlkI7b.png" alt="13.png"><br><img src="https://s2.loli.net/2023/05/29/AoJwyuFzL9QmsvG.png" alt="8.png"><br>DMA方式的流程图<br><img src="https://s2.loli.net/2023/05/29/MeaBzfoYcu9gkEv.png" alt="14.png"></p><h1 id="通道方式"><a href="#通道方式" class="headerlink" title="通道方式"></a>通道方式</h1><p><img src="https://s2.loli.net/2023/05/29/RmJkYWaC4yoAd2V.png" alt="15.png"></p><h1 id="多一点细心，多一点耐心！"><a href="#多一点细心，多一点耐心！" class="headerlink" title="==多一点细心，多一点耐心！=="></a>==多一点细心，多一点耐心！==</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象</title>
      <link href="/2023/05/25/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/05/25/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="1、类变量"><a href="#1、类变量" class="headerlink" title="1、类变量"></a>1、类变量</h1><p>类变量是被类的所有实例共享的。<br>类变量具体放的位置在哪？在内存中的那个区域，这和jdk的版本是有关的<br>静态变量在类加载的时候就生成了，即使没有创建类实例也能访问，当然通过实例来实现<br><img src="https://s2.loli.net/2023/05/25/uRKgvbmojwp3AIM.png" alt="4.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类变量定义</span><br><span class="line">访问修饰符 <span class="keyword">static</span> 类型 变量名</span><br></pre></td></tr></table></figure><h1 id="2、类方法"><a href="#2、类方法" class="headerlink" title="2、类方法"></a>2、类方法</h1><p>1、只需要在普通方法前面加上一个static就可以把该方法变成类方法<br>2、当方法中不涉及任何和对象相关的成员的时候把方法设置成静态方法可以提高效率<br>3、类方法中不允许使用和对象相关的关键字如this、super</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类变量定义</span><br><span class="line">访问修饰符 <span class="keyword">static</span> 返回值类型 方法名()&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们需要记住静态方法只能访问静态成员，非静态可以访问静态和非静态</p></blockquote><h1 id="3、main方法"><a href="#3、main方法" class="headerlink" title="3、main方法"></a>3、main方法</h1><p>1、main方法是JVM在调用，访问权限必须是public<br>2、java虚拟机在调用main方法时不必实例化对象<br>使用细节<br>main方法可以直接使用静态成员，但不能直接使用非静态成员，如果要使用非静态成员需要实例化出来一个对象</p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>代码块相当于构造器（或则说是对构造器的补充），可以做初始化操作<br>使用方法：当构造器中有多个重复语句时，使用比较方便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修饰符可以写也可以不写，写的话就只能写static，后面的;可以写也可以不写</span></span><br><span class="line">[修饰符]</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>==使用细节==：<br>1、如果修饰符是static，那么代码块在类加载时被执行，且只会被执行一次<br>2、类加载的时间：创建类的实例、创建子类的实例父类也会被加载、使用类的静<br>3、对象实例化时，类内部的执行顺序：1、静态代码块、静态属性初始化 2、普通代码块、普通属性初始化 3、构造器<br>4、先加载父类，再加载父类，再初始化父类再初始化子类<br><img src="https://s2.loli.net/2023/05/25/uCdrgRMbPkUhmQW.png" alt="5.png"></p><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>保证一个类只有一个实例<br>单例模式分为两种一种是饿汉式、一种是懒汉式<br>1、将构造器私有化 2、在类的内部直接创建 3、提供一个static方法直接返回创建的对象<br>懒汉式和饿汉式的区别在于实例化的时间，饿汉式是在类加载的时候就创建了实例，懒汉式是在调用getInstance时才会创建实例<br>懒汉式不会造成资源的浪费<br><img src="https://s2.loli.net/2023/05/25/SuFdtcjMhEnbmeL.png" alt="6.png"></p><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p>1、当一个类不希望被其他类继承时，可以在这个类前面加上final<br>2、当父类的一样方法不希望被重写时，可以用final修饰<br>3、当类的某个属性不希望被修改时，可以用final修饰，<br>其实可以这样理解当一个东西不希望被修改时，我们可以final修饰<br>使用细节<br>1、final修饰的属性被称为常量一般用大写字母+_组成,而且必须进行初始化<br>2、如果final修饰的是静态的，那么初始化时只能在定义时或则静态代码段<br>3、如果类不是final类，但是含有final方法，则该方法虽然不能重写，但却可以继承，子类使用。<br>4、如果类已经用final修饰了，就没有必要再用final修饰方法了。<br>5、包装类（Integer，Double，Float，Boolean等都是final），String也是final类。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java注解</title>
      <link href="/2023/05/24/Java%E6%B3%A8%E8%A7%A3/"/>
      <url>/2023/05/24/Java%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="注解的理解"><a href="#注解的理解" class="headerlink" title="注解的理解"></a>注解的理解</h1><p>（1）、注解也被称为元数据，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息，附加在代码中的一些元信息<br>（2）、和注释一样，注解不影响程序的逻辑，但注解可以被编译或运行，相当于嵌在代码中的补充信息</p><h1 id="Overried"><a href="#Overried" class="headerlink" title="@Overried"></a>@Overried</h1><p>（1）、Override只能用在方法上，用于重写父类的方法（可以是直接父类，也可以是非直接父类）<br>（2）、@Target修饰注解的注解</p><h1 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h1><p>（1）、Deprecated修饰某个元素，表示该元素已经过时<br>（2）、可以修饰方法、类、字段、包</p><h1 id="SuppressWarings"><a href="#SuppressWarings" class="headerlink" title="SuppressWarings"></a>SuppressWarings</h1><p>抑制编译警告<br>关于抑制的范围和SuppressWarings放置的范围有关</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抑制所有警告</span></span><br><span class="line"><span class="meta">@SuppressWarings(&quot;all&quot;)</span></span><br></pre></td></tr></table></figure><h1 id="四种元注解"><a href="#四种元注解" class="headerlink" title="四种元注解"></a>四种元注解</h1><p>修饰注解的注解</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性dp</title>
      <link href="/2023/05/19/%E7%BA%BF%E6%80%A7dp/"/>
      <url>/2023/05/19/%E7%BA%BF%E6%80%A7dp/</url>
      
        <content type="html"><![CDATA[<h1 id="P2285-HNOI2004-打鼹鼠"><a href="#P2285-HNOI2004-打鼹鼠" class="headerlink" title="P2285 [HNOI2004]打鼹鼠"></a><a href="https://www.luogu.com.cn/problem/P2285">P2285 [HNOI2004]打鼹鼠</a></h1><blockquote><p>这道题目类似最长上升子序列</p></blockquote><p>这是一道线性dp的题目<br>怎么设置状态呢？<br>f[i]：表示最后一只鼹鼠选择i的最大值<br>转移：f[i] = max(f[i], f[j] + 1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">wy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t, x, y;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(wy t1, wy t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(t1.t - t2.t) &gt;= <span class="built_in">abs</span>(t1.x - t2.x) + <span class="built_in">abs</span>(t1.y - t2.y))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a[i].t, &amp;a[i].x, &amp;a[i].y);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)f[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; -- j)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(a[i], a[j]))</span><br><span class="line">f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//int t; scanf(&quot;%d&quot;, &amp;t);</span></span><br><span class="line"><span class="comment">//while(t --) solve();</span></span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P1725-琪露诺"><a href="#P1725-琪露诺" class="headerlink" title="P1725 琪露诺"></a><a href="https://www.luogu.com.cn/problem/P1725">P1725 琪露诺</a></h1><p>一道线性dp的题目<br>状态设置：f[i]:表示到达位置i时的最大价值<br>状态转移：f[i] = max(f[i], f[j] + a[i])(i - r =&lt; j &lt;= i - l)<br>这样做显然枚举状态是O（n）转移也需要O（n），所以时间复杂度是O（n^2）的显然会T<br>状态我们是一定要枚举的，我们能优化的只有转移的计算量， 我们需要快速找到i - r =&lt; j &lt;= i - l的f[j]的最大值，<br>我们发现当i+1， 我们要求的是 i - r + 1=&lt; j &lt;= i - l + 1中的最大值，也就是说只新增了一个元素，减少了一个元素我们要求的是区间的最大值，这样很明显我们可以用滑动窗口优化，来维护这样一个长度为r - i + 1的窗口的最大值<br>这样这道题就解决了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N], a[N], ans = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> q[N], tt = <span class="number">-1</span>, hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, l, r; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;l, &amp;r);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="built_in">sizeof</span> (f));</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; i - r)++ hh;</span><br><span class="line"><span class="keyword">while</span>(hh &lt;= tt &amp;&amp; f[q[tt]] &lt; f[i - l]) -- tt;</span><br><span class="line">q[++ tt] = i - l;</span><br><span class="line">f[i] = f[q[hh]] + a[i];</span><br><span class="line"><span class="keyword">if</span>(i + r &gt; n)ans = <span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">//int t; scanf(&quot;%d&quot;, &amp;t);</span></span><br><span class="line"><span class="comment">//while(t --) solve();</span></span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P1874-快速求和"><a href="#P1874-快速求和" class="headerlink" title="P1874 快速求和"></a><a href="https://www.luogu.com.cn/problem/P1874">P1874 快速求和</a></h1><p>这道题目可以dp也可以搜索，整体思路上不是很难，但是细节比较难搞<br>dp的思路：<br>状态：f[i][j]表示前i个数组合成j的最小加号<br>转移：f[i][j] = min(f[k][j - v] + 1, f[i][j])，<br>时间复杂度：len（s）* len（s）* m</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">50</span>][N], a[<span class="number">50</span>], n, m; </span><br><span class="line"><span class="type">char</span> c[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)a[i] = c[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">res = res * <span class="number">10</span> + a[i];</span><br><span class="line"><span class="keyword">if</span>(res &gt; <span class="number">1e7</span>)<span class="keyword">return</span> <span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">1</span>; -- k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v = <span class="built_in">val</span>(k + <span class="number">1</span>, i);</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span>(v &lt;= j)f[i][j] = <span class="built_in">min</span>(f[k][j - v] + <span class="number">1</span>, f[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for(int i = 0; i &lt;= n; ++ i)</span></span><br><span class="line"><span class="comment">//for(int j = 0; j &lt;= m; ++ j)</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; j &lt;&lt; &#x27; &#x27; &lt;&lt; f[i][j] &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">val</span>(<span class="number">1</span>, n) == m)cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span><span class="keyword">if</span>(f[n][m] &gt; n)cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span>cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">n = <span class="built_in">strlen</span>(c + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">pre</span>();</span><br><span class="line"><span class="built_in">solve</span>(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搜索：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">50</span>], n, m; </span><br><span class="line"><span class="type">char</span> c[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)a[i] = c[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算从l到r这段数的大小</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">val</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; ++ i)res = res * <span class="number">10</span> + a[i];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//u表示当前数的大小，k表示枚举到数的位置， cnt表示添加加号的数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = u + <span class="built_in">val</span>(k + <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">if</span>(tmp &lt; m)<span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt &gt; ans)<span class="keyword">return</span>; </span><br><span class="line"><span class="keyword">if</span>(tmp == m)</span><br><span class="line">&#123;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, cnt);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = k + <span class="number">1</span>; i &lt;= n; ++ i)<span class="built_in">dfs</span>(u + <span class="built_in">val</span>(k + <span class="number">1</span>, i), i, cnt + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c + <span class="number">1</span>);</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line">n = <span class="built_in">strlen</span>(c + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">pre</span>();</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ans == <span class="number">1e9</span>)   cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span>    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="方格取数"><a href="#方格取数" class="headerlink" title="方格取数"></a><a href="https://www.luogu.com.cn/problem/P1004">方格取数</a></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N * <span class="number">2</span>][N][N], a[N][N], n; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y, w;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>)<span class="keyword">break</span>; </span><br><span class="line">a[x][y] = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span> * n; ++ k)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">min</span>(n, k); ++ i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">min</span>(n, k); ++ j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t1 = <span class="built_in">max</span>(f[k - <span class="number">1</span>][i - <span class="number">1</span>][j - <span class="number">1</span>], f[k - <span class="number">1</span>][i][j]);</span><br><span class="line"><span class="type">int</span> t2 = <span class="built_in">max</span>(f[k - <span class="number">1</span>][i - <span class="number">1</span>][j], f[k - <span class="number">1</span>][i][j - <span class="number">1</span>]);</span><br><span class="line">f[k][i][j] = <span class="built_in">max</span>(t1, t2) + a[i][k - i] + a[j][k - j];</span><br><span class="line"><span class="keyword">if</span>(i == j)f[k][i][j] -= a[i][k - i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[<span class="number">2</span> * n][n - <span class="number">1</span>][n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">freopen</span>(<span class="string">&quot;1.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="built_in">solve</span>(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P2679-NOIP2015-提高组-子串"><a href="#P2679-NOIP2015-提高组-子串" class="headerlink" title="P2679 [NOIP2015 提高组] 子串"></a><a href="https://www.luogu.com.cn/problem/P2679">P2679 [NOIP2015 提高组] 子串</a></h1><blockquote><p>状态表示：f[i][j][k]:表示考虑a中前i个字符，b中前j个字符，并且已经使用了k个字符串的方案数<br>转移的话需要分类讨论：<br>当a[i] != b[j]时,f[i][j][k] = f[i - 1][j][k]<br>当a[i] == b[j]并且a[i - 1] != b[j - 1]时, f[i][j][k] = f[i - 1][j][k] + f[i - 1][j - 1][k - 1]<br>当a[i] == b[j]并且a[i - 1] == b[j - 1], 并且a[i - 2] != b[j - 2]时 f[i][j][k] = f[i - 1][j][k] + f[i - 1][j - 1][k - 1] + f[i - 2][j - 2][k - 1]<br>当a[i - t] != b[j - t]时 f[i][j][k] = f[i - 1][j][k] + f[i - 1][j - 1][k - 1] + f[i - 2][j - 2][k - 1] + … + f[i - t][j - t][k - 1];<br>我们可以用sum[i][j][k]表示前缀f[i - 1][j - 1][k - 1] + f[i - 2][j - 2][k - 1] + … + f[i - t][j - t][k - 1];<br>而sum[i][j][k] = f[i - 1][j - 1][k - 1] + s[i - 1][j - 1][k],递推可以边做边更换新<br>另外需要注意用滚动数组，因为会爆空间需要滚一下。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">210</span>, mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][M][M], n, m, d, sum[<span class="number">2</span>][M][M];</span><br><span class="line"><span class="type">char</span> a[N], b[M]; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;d);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, b + <span class="number">1</span>);</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="built_in">min</span>(d, j); ++ k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] != b[j])sum[i &amp; <span class="number">1</span>][j][k] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span>sum[i &amp; <span class="number">1</span>][j][k] = (f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j - <span class="number">1</span>][k - <span class="number">1</span>] + sum[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j - <span class="number">1</span>][k]) % mod;</span><br><span class="line">f[i &amp; <span class="number">1</span>][j][k] = (f[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j][k] + sum[i &amp; <span class="number">1</span>][j][k]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[n &amp; <span class="number">1</span>][m][d]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="built_in">solve</span>(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="P1435-IOI2000-回文字串"><a href="#P1435-IOI2000-回文字串" class="headerlink" title="P1435 [IOI2000] 回文字串"></a><a href="https://www.luogu.com.cn/problem/P1435">P1435 [IOI2000] 回文字串</a></h1><blockquote><p>题目的含义是求原串和翻转串的最长公共子序列，直接套用最长公共子序列模版即可</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a + <span class="number">1</span>);</span><br><span class="line">n = <span class="built_in">strlen</span>(a + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)b[n - i + <span class="number">1</span>] = a[i];</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">&#123;</span><br><span class="line">f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]); </span><br><span class="line"><span class="keyword">if</span>(a[i] == b[j])f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, n - f[n][n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="built_in">solve</span>(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://www.luogu.com.cn/problem/P1854">P1854 花店橱窗布置</a></p><blockquote><p>这道题目有两种思路，状态设置的不同，转移方程也会不一样<br>先说一下我最开始的思路，最开始考虑的是n^2的做法，<br>f[i][j]表示考虑前i朵花放在前j个花瓶中的最大值<br>转移的话就是考虑第i朵花放不放在第j个花瓶就会有<br>f[i][j] = max(f[i][j - 1], f[i - 1][j - 1] + w[i][j]);</p></blockquote><blockquote><p>另一个思路是f[i][j]表示第i朵花放在第j个花瓶中的最大值，这种方法的复杂度是n^3需要枚举转移即枚举第i-1朵花是放在哪个花瓶<br>f[i][j] = max(f[i][j], f[i - 1][k]);</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> map[<span class="number">101</span>][<span class="number">101</span>],f[<span class="number">101</span>][<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;,path[<span class="number">101</span>][<span class="number">101</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fl,v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">1</span>||y&lt;<span class="number">1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(path[x][y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(x<span class="number">-1</span>,y<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">print</span>(x,y<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;fl,&amp;v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=fl;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=v;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;map[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=fl;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=v;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i][j<span class="number">-1</span>]&lt;f[i<span class="number">-1</span>][j<span class="number">-1</span>]+map[i][j]||i&gt;=j)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]+map[i][j];</span><br><span class="line">                path[i][j]=<span class="number">1</span>;<span class="comment">//记录对于每个状态是怎么到达的</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j]=f[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[fl][v]);</span><br><span class="line">    <span class="built_in">print</span>(fl,v);<span class="comment">//递归方式打印解</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> second y</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N][N], w[N][N], pre[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">print</span>(x - <span class="number">1</span>, pre[x][y]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i][j]);</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">-127</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= m; ++ j)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = j - <span class="number">1</span>; k &gt;= <span class="number">1</span>; -- k)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f[i][j] &lt; f[i - <span class="number">1</span>][k] + w[i][j])</span><br><span class="line">&#123;</span><br><span class="line">pre[i][j] = k;</span><br><span class="line">f[i][j] = f[i - <span class="number">1</span>][k] + w[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t = <span class="number">-1e9</span>, pos = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(f[n][i] &gt; t)</span><br><span class="line">&#123;</span><br><span class="line">pos = i;</span><br><span class="line">t = f[n][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][pos]);</span><br><span class="line"><span class="built_in">print</span>(n, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="built_in">solve</span>(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;cstdio&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;cstring&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;algorithm&quot;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,k,l,r;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>][<span class="number">110</span>],showti[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!x||!y)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>&amp;&amp;y==<span class="number">1</span>)<span class="comment">//考虑到第一位可能不取的情况，特判一下</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;1 &quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dp[x<span class="number">-1</span>][y<span class="number">-1</span>]+showti[y][x]==dp[x][y])<span class="comment">//这一位放了 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">print</span>(x<span class="number">-1</span>,y<span class="number">-1</span>),<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dp[x<span class="number">-1</span>][y]==dp[x][y])<span class="comment">//这一位没放 </span></span><br><span class="line"><span class="built_in">print</span>(x<span class="number">-1</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(dp));<span class="comment">//考虑到美观度可能会小于0，必须预处理为极小值 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;showti[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    dp[i][<span class="number">1</span>]=showti[<span class="number">1</span>][i],dp[i][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//预处理，后面 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;++i)<span class="comment">//第i个花瓶</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)<span class="comment">//j朵花</span></span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+showti[j][i]);<span class="comment">//每一位的状态只可能从前一个花盆装和前一个花盆不装转移过来 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[m][n]);</span><br><span class="line"><span class="built_in">print</span>(m,n);<span class="comment">//递归输出，比较方便 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://www.luogu.com.cn/problem/P1833">P1833 樱花</a></p><blockquote><p>这道题目是一道混合背包问题，分别处理就好</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[N], w[M], v[M];</span><br><span class="line"><span class="type">int</span> n, m, cnt, hh1, hh2, mm1, mm2;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d:%d&quot;</span>, &amp;hh1, &amp;mm1);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d:%d&quot;</span>, &amp;hh2, &amp;mm2);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">m = hh2 * <span class="number">60</span> + mm2 - hh1 * <span class="number">60</span> - mm1;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line"><span class="keyword">if</span>(!c)</span><br><span class="line">&#123;</span><br><span class="line">c = (m + <span class="number">1</span>) / a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(k &lt;= c)</span><br><span class="line">&#123;</span><br><span class="line">w[++ cnt] = k * b;</span><br><span class="line">v[cnt] = k * a;</span><br><span class="line">c -= k;</span><br><span class="line">k *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c)</span><br><span class="line">&#123;</span><br><span class="line">w[++ cnt] = c * b;</span><br><span class="line">v[cnt] = c * a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; --  j)</span><br><span class="line">f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[m]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="built_in">solve</span>(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://www.luogu.com.cn/problem/P2340">P2340 [USACO03FALL] Cow Exhibition G</a><br><img src="https://s2.loli.net/2023/07/07/zxoGLXyTduq6CmS.jpg" alt="e97c136c9e2311cc396b448d4559098.jpg"></p><blockquote><p>这道题目是有限制的选择问题思路上并不难，但是有一些特殊和细节的处理需要特别关注<br>第一点就是因为这里的贡献有负数，可能会导致状态表示的时候下标出现负数，所以需要进行一个偏移量的处理，即给所有的第二维都增加一个偏移量M，偏移量取多少合适？只要满足所有的状态的下标都大于0就是合适的<br>第二点就是需要进行空间优化，滚动数组或者直接把第一位省略都行，这里空间优化可以参考01背包的优化</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">410</span>, M = <span class="number">4e5</span>;</span><br><span class="line"><span class="type">int</span> f[M * <span class="number">2</span> + <span class="number">10</span>] , iq[N], eq[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;iq[i], &amp;eq[i]);</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">f[M] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//0 &lt;= j - eq[i] &lt;= 2*M  &amp;&amp; j &gt;= 0，这里最开始没想明白</span></span><br><span class="line"><span class="keyword">if</span>(eq[i] &gt;= <span class="number">0</span>)<span class="keyword">for</span>(<span class="type">int</span> j = M + M + eq[i]; j &gt;= eq[i]; --  j)f[j] = <span class="built_in">max</span>(f[j], f[j - eq[i]] + iq[i]);</span><br><span class="line"><span class="keyword">else</span><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= M + M + eq[i]; ++ j)f[j] = <span class="built_in">max</span>(f[j], f[j - eq[i]] + iq[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找答案的时候需要枚举</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= M; ++ i)</span><br><span class="line">        <span class="comment">//注意题目中说了合法的答案，iq，eq都需要&gt;=0，所以i，发f[i + M]都需要&gt;=0</span></span><br><span class="line"><span class="keyword">if</span>(f[M + i] &gt;= <span class="number">0</span>)ans= <span class="built_in">max</span>(ans, f[M + i] + i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="built_in">solve</span>(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库的恢复技术</title>
      <link href="/2023/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="存储器结构"><a href="#存储器结构" class="headerlink" title="存储器结构"></a>存储器结构</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>1、易失性存储器：内存、高速缓冲存储器<br>2、非易失性存储器：磁盘、磁带<br>3、稳定存储器：理想的存储器，其中信息永不丢失</p><h2 id="稳定存储器的实现"><a href="#稳定存储器的实现" class="headerlink" title="稳定存储器的实现"></a>稳定存储器的实现</h2><p>要实现稳定存储器，就要在多个非易失性存储介质上以独立的故障模式复制所需要的信息，并且以某种受控的方式更新数据，以保证数据传送的过程中发生的故障不会破坏所需信息<br>采用冗余独立磁盘阵列（RAID）可以保证单个磁盘的故障不会导致数据丢失。</p><h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><p>数据库通常驻留在磁盘上，并且划分成固定长度的块。块是磁盘传送的基本单位，可能包含多个记录。<br>缓冲块是暂时驻留在主存中的块，物理块位于磁盘上.<br><img src="https://s2.loli.net/2023/05/19/dxkSlZ5GOY2UwBX.png" alt="8.png"><br><img src="https://s2.loli.net/2023/05/19/3s1nLVMHCtqOGzx.png" alt="9.png"></p><h1 id="基于日志的恢复技术"><a href="#基于日志的恢复技术" class="headerlink" title="基于日志的恢复技术"></a>基于日志的恢复技术</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>1、日志是日志记录的序列，记录了数据库中所有的更新活动。登记了每个事务的开始标记、结束标记、和所有更新操作<br>2、事务结束可能是正常提交（commit）、也可能是异常终止（abort）<br>3、事务的更新可能是插入、删除、更改<br><img src="https://s2.loli.net/2023/05/19/P7bkB3jYZUir2XK.png" alt="11.png"><br><img src="https://s2.loli.net/2023/05/19/iPIcnWoEyjKxhgB.png" alt="10.png"><br>登记日志的原则<br>1、日志记录必须严格按并发事务的时间次序登记<br>2、必须先记日记后写数据库</p><p>redo（Ti）：根据日志记录，登记日志的次序，将事务Ti每次更新的数据对象的新值用write操作重新写到数据库中。redo执行多次等价于执行一次<br>undo（Ti）：根据日志，按照登记日志的相反次序，将事务Ti每次更新的数据对象的旧值用write操作写回数据库。</p><h2 id="延迟更新"><a href="#延迟更新" class="headerlink" title="延迟更新"></a>延迟更新</h2><p>将对事务的更新推迟到事务提交之后遵循以下原则<br>（1）、每个事务在到达提交点之前不能更新数据库<br>（2）、在一个事务的所有更新操作的日志记录写入稳定存储器之前，该事务不能达到提交点</p><p>延迟更新技术只需要在日志中记录被更新数据对象的新值</p><h3 id="事务故障的处理："><a href="#事务故障的处理：" class="headerlink" title="事务故障的处理："></a>事务故障的处理：<img src="https://s2.loli.net/2023/05/19/Isqxb1g5RNcVmJY.png" alt="12.png"></h3><h3 id="系统故障的处理"><a href="#系统故障的处理" class="headerlink" title="系统故障的处理"></a>系统故障的处理</h3><p><img src="https://s2.loli.net/2023/05/19/AWti8x3QVlHmOkY.png" alt="13.png"><br><img src="https://s2.loli.net/2023/05/19/9YEgXCwrVPNTApO.png" alt="14.png"><br>对于（a）时刻：这时没有commit所有事务都未提交所以不用管<br>对于（b）时刻：T0commit所以对T0事务执行redo<br>c：T0、T1均commit执行redo</p><h2 id="即时更新"><a href="#即时更新" class="headerlink" title="即时更新"></a>即时更新</h2><p>允许事务在活跃状态时就将更新输出到数据库上。处于活动状态的事务直接在数据库上实施的更新称为非提交更新。遵循以下原则<br>（1）、在&lt;Ti， Xj， V1， V2&gt;安全地输出到稳定性存储器之前，事务Ti不能更新<br>（2）、在所有&lt;Ti， Xj， V1， V2&gt;类型的日志记录安全地输出到稳定存储器之前，不孕寻事务提交<br><img src="https://s2.loli.net/2023/05/19/R6bK9IF53tTEYPJ.png" alt="15.png"></p><h3 id="事务故障处理"><a href="#事务故障处理" class="headerlink" title="事务故障处理"></a>事务故障处理</h3><p><img src="https://s2.loli.net/2023/05/19/JjmWcPTFwlHkg85.png" alt="16.png"></p><h3 id="系统故障的处理-1"><a href="#系统故障的处理-1" class="headerlink" title="系统故障的处理"></a>系统故障的处理</h3><p><img src="https://s2.loli.net/2023/05/19/rX4zV8O19miqspK.png" alt="17.png"><br><img src="https://s2.loli.net/2023/05/19/uT3fSvqFnwByhc9.png" alt="18.png"></p><blockquote><p>延迟更新和即时更新对数据库的恢复的不同之处就是因为更新数据库的时间不同导致，延迟更新是用已经commit的去恢复，没有commit的我们本身没有对数据库操作也就不用恢复，而即时更新是我们在commit之前只要日志记录成功我们就可以更新数据库，一旦出现故障，那些没有commit的我们用记录中的旧值去更新，commit的用新值去更新。</p></blockquote><h1 id="基于检查点的恢复技术"><a href="#基于检查点的恢复技术" class="headerlink" title="基于检查点的恢复技术"></a>基于检查点的恢复技术</h1><p>对于系统故障恢复时，必须搜索日志，确定哪些事务是需要redo的，哪些事务是需要undo的，这个过程需要搜索整个日志，这里就会有两个问题<br>1、日志一般来说很大，搜索起来很耗时<br>2、有些事务已经写入数据库，再次执行redo虽然不会错，但是会耗时<br>检查点技术的使用就很好的解决了这两个问题<br>通过定期建立检查点来解决<br><img src="https://s2.loli.net/2023/05/19/BykogiKSUsFPNtv.png" alt="21.png"><br>基于即时更新的检查点恢复过程<br><img src="https://s2.loli.net/2023/05/19/5blHwdazZtniBPI.png" alt="22.png"><br><img src="https://s2.loli.net/2023/05/19/9Q4IPJL3GSl8eHr.png" alt="23.png"><br><img src="https://s2.loli.net/2023/05/19/vByPh4NSRaLw2qM.png" alt="19.png"><br><img src="https://s2.loli.net/2023/05/19/WOdBYShrF9wvLfH.png" alt="20.png"></p><h1 id="介质故障恢复技术"><a href="#介质故障恢复技术" class="headerlink" title="介质故障恢复技术"></a>介质故障恢复技术</h1><p>虽然介质故障不常见但危害巨大<br>首先说一下转储的概念<br>转储是指将整个或部分数据库复制到磁带或另一个磁盘上，产生数据库后备副本的过程。根据转储时是否允许事务运行可以分为静态转储和动态转储<br>静态转储<br><img src="https://s2.loli.net/2023/05/19/ogkKmyYnU9dVNLI.png" alt="24.png"><br>动态转储<br><img src="https://s2.loli.net/2023/05/19/z1PXSJLgVGo6rUq.png" alt="25.png"><br>海量转储和增量转储<br><img src="https://s2.loli.net/2023/05/19/xpPUBzNgRQye63S.png" alt="26.png"><br><img src="https://s2.loli.net/2023/05/19/x9swh3Z2Jcglodm.png" alt="27.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总线</title>
      <link href="/2023/05/17/%E6%80%BB%E7%BA%BF/"/>
      <url>/2023/05/17/%E6%80%BB%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="概概述"><a href="#概概述" class="headerlink" title="概概述"></a>概概述</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1、总线：是构成计算机互联的机构，是多个系统功能部之间进行数据传输的公共通路<br>2、总线的分类：<br>内部总线、系统总线、IO总线<br>内部总线：cpu连接寄存器及各运算部件的总线<br>系统总线：cpu连接其他高速功能（如存储器）的总线<br>IO总线：中低速IO设备之间互相连接的总线<br>3、总线的特性<br><img src="https://s2.loli.net/2023/05/16/PjbMoy3nA51e2kT.png" alt="2.png"><br>4、总线带宽<br>总线本身能够达到的最高传输速率，单位是MB/s（兆字节每秒）<br>也可以指一次操作可以传输的数据位数</p><h2 id="总线的连接方式"><a href="#总线的连接方式" class="headerlink" title="总线的连接方式"></a>总线的连接方式</h2><p>通过适配器将各种外围设备连接到cpu上，适配器也被称为接口</p><h3 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h3><p><img src="https://s2.loli.net/2023/05/16/fqBpua5s1GPzvEY.png" alt="3.png"></p><h3 id="多总线结构"><a href="#多总线结构" class="headerlink" title="多总线结构"></a>多总线结构</h3><p><img src="https://s2.loli.net/2023/05/16/cMi7YqC96bzSyes.png" alt="4.png"><br>1、高速、中速、低速设备连接到了不同的总线上同时进行工作<br>2、提高了总线的效率和吞吐量<br>3、处理器结构的变化不影响高速总线</p><h3 id="总线的内部结构"><a href="#总线的内部结构" class="headerlink" title="总线的内部结构"></a>总线的内部结构</h3><h4 id="早期总线的内部结构"><a href="#早期总线的内部结构" class="headerlink" title="早期总线的内部结构"></a>早期总线的内部结构</h4><p>信号线可以分为三类：<br>1、地址线：一般是单向的，用于传送主存和设备的地址<br>2、数据线：双向的，用来传送数据<br>3、控制线: 单向的<br><img src="https://s2.loli.net/2023/05/16/6y7mbMqlFevdKno.png" alt="5.png"><br><img src="https://s2.loli.net/2023/05/16/EU2pWFkPybOnm7a.png" alt="6.png"></p><h4 id="当代总线的内部结构"><a href="#当代总线的内部结构" class="headerlink" title="当代总线的内部结构"></a>当代总线的内部结构</h4><p>1、数据传输线：由地址线、数据线、控制线组成，为了减少引脚数量，64位数据的低32位数据线常常和地址线采用多路复用<br>2、仲裁线：总线请求线、总线授权线<br>3、中断、同步总线：用于处理带优先级的中断操作<br>4、公用线：包括时钟信号线、电源线、地线、系统复位线、加电或断电的时序信号线<br><img src="https://s2.loli.net/2023/05/16/aG7zZ8KTHFV3lg2.png" alt="7.png"></p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>1、CPU总线：包含64位数据线和32地址线的同步总线<br>2、PCI总线：用于连接高速的I/O设备模块<br>3、ISA总线：用于连接低速的I/O设备<br><img src="https://s2.loli.net/2023/05/16/GJVkyA6mhK9pBX8.png" alt="8.png"></p><h1 id="总线接口"><a href="#总线接口" class="headerlink" title="总线接口"></a>总线接口</h1><h2 id="信息的传送方式、"><a href="#信息的传送方式、" class="headerlink" title="信息的传送方式、"></a>信息的传送方式、</h2><p>共有三种串行传输、并行传送、分时传送</p><h3 id="串行传送"><a href="#串行传送" class="headerlink" title="串行传送"></a>串行传送</h3><p>只有一根传输线，采用脉冲传送，有拆卸（并串转换）和装配（串并转换）过程<br>优点是只需要一根传送线，成本比较低<br><img src="https://s2.loli.net/2023/05/16/rgfwVCo3mqSdvxQ.png" alt="2.png"></p><h3 id="并行传送"><a href="#并行传送" class="headerlink" title="并行传送"></a>并行传送</h3><p>并行传送采用电位传送<br>优点传送数据的速度比串行传送速度快的多<br><img src="https://s2.loli.net/2023/05/16/AVN7RYrGUXiWLF5.png" alt="3.png"></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><img src="https://s2.loli.net/2023/05/16/pMrfAGPT7yQCV9B.png" alt="4.png"></p><h3 id="接口的功能"><a href="#接口的功能" class="headerlink" title="接口的功能"></a>接口的功能</h3><p>1、控制：控制外围设备的动作<br>2、缓冲：补偿各种设备在速度上的差异<br>3、状态：监视外围设备工作状态并保存状态信息<br>4、转换：可以完成任何要求的数据转换<br>5、整理：完成一些特别的功能，在需要时可以修改字计数器或当前内存地址寄存器<br>6、程序中断：<br><img src="https://s2.loli.net/2023/05/16/U9erlwpc6YkuLxQ.png" alt="1.png"></p><h1 id="总线的仲裁"><a href="#总线的仲裁" class="headerlink" title="总线的仲裁"></a>总线的仲裁</h1><p>仲裁的作用：解决多个主设备同时竞争总线控制权</p><h2 id="集中式仲裁"><a href="#集中式仲裁" class="headerlink" title="集中式仲裁"></a>集中式仲裁</h2><p>每个模块有两条线连接到中央仲裁器，一条是送往仲裁器的总线请求信号BR，一条是仲裁器送出的总线授权信号BG</p><h3 id="链式查询方式"><a href="#链式查询方式" class="headerlink" title="链式查询方式"></a>链式查询方式</h3><p>链式查询方式的主要特点：总线授权信号BG串行地从一个I/O接口传送到下一个I/O接口。假如BG到达的接口总无总线请求，则继续往下查询；直到BG到达的接口有总线请求就不再往下继续查询，这就意味着该I/O接口获得了总线控制权<br>我们可以知道离总线控制部件越近的设备具有的优先级越高<br>通过这种方式可以说用很少的几根线就可以实现按一定的优先次序实现总线仲裁，并且容易实现扩充设备<br><img src="https://s2.loli.net/2023/05/16/gdr6lESUGWXxkvO.png" alt="6.png"><br><img src="https://s2.loli.net/2023/05/16/VaYzhmR1S9lE7Td.png" alt="5.png"></p><h3 id="计数器定时查询方式、"><a href="#计数器定时查询方式、" class="headerlink" title="计数器定时查询方式、"></a>计数器定时查询方式、</h3><h3 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h3><p>每一个共享总线的设备均有一对总线请求BRi和总线授权线BGi<br>总线仲裁器中有一个排队电路，根据一定的优先次序决定首先响应哪个设备的请求<br><img src="https://s2.loli.net/2023/05/16/D7wvSB31ENkWrnd.png" alt="7.png"><br>独立请求方式的特点<br><img src="https://s2.loli.net/2023/05/16/N3wYQngl1cqGhZm.png" alt="8.png"></p><h2 id="分布式仲裁"><a href="#分布式仲裁" class="headerlink" title="分布式仲裁"></a>分布式仲裁</h2><p>分布式仲裁不需要总仲裁器，每一个主方功能模块都有一个自己的仲裁号和仲裁器<br>当一个主功能模块有总线请求时，将自己唯一的仲裁号发送到仲裁总线上，每个仲裁器将仲裁总线上得到的号与自己的号进行比较。如果仲裁总线上的号搭，则它的总线请求不予相应，并撤销他的仲裁号<br><img src="https://s2.loli.net/2023/05/16/h5xR6LyZKJuTNQn.png" alt="9.png"></p><h1 id="总线的定时和数据传输模式"><a href="#总线的定时和数据传输模式" class="headerlink" title="总线的定时和数据传输模式"></a>总线的定时和数据传输模式</h1><p>总线事务：<br>1、请求阶段<br>2、仲裁阶段<br>3、寻址阶段<br>4、传输阶段<br>5、释放阶段</p><h2 id="同步定时"><a href="#同步定时" class="headerlink" title="同步定时"></a>同步定时</h2><p>系统采用一个统一的时钟信号，协调发送和接收信息<br>优点：传送速度快，具有较高的传输效率，总线逻辑控制简单<br>缺点：主从设备属于强制性同步，不能及时进行数据通信的有效性检验，可靠性较差<br>适用于总线长度较短、总线所接部件存取时间接近的系统<br>读命令<br>可以看到先是地址段有效，然后是读命令有效，最后是数据有效<br><img src="https://s2.loli.net/2023/05/17/9Hu1ioCt6wdSRmT.png" alt="7.png"><br>写命令<br>看到先是地址有效，然后是数据有效而且比读操作有效的时间更早，然后是写操作，持续的时间也比读操作更长</p><h2 id="异步定时"><a href="#异步定时" class="headerlink" title="异步定时"></a>异步定时</h2><p>没有统一的时钟，没有固定的时间间隔完全靠双方的握手信号来实现定时控制<br>优点是总线周期长度可变<br>缺点：比同步控制方式复杂，速度也比同步控制慢<br><img src="https://s2.loli.net/2023/05/17/AMXGB4rxv5HSpda.png" alt="9.png"><br><img src="https://s2.loli.net/2023/05/17/gQ1EvlaNupT6OP9.png" alt="8.png"></p><h1 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h1><p>1、ISA工业标准体系结构。最早出现的微型计算机的系统总线由IBM公司制定<br>2、EISA，再ISA基础上将总线宽度提升为32位<br>3、VISA考虑了CPU、Cache和主存的直接连接<br>4、PCI外设部件互联总线，目前常用的总线，地址总线与数据总线是分时复用的<br>5、AGP总线，基于PCI能够提供4倍于PCI的速度，采用点对点的方式<br>6、PCIe：为了提高速度改为了串行传送，更高的系统总线的吞吐量<br>7、USB<br><img src="https://s2.loli.net/2023/05/17/N1MUlJhYVCKb5T7.png" alt="10.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java进程</title>
      <link href="/2023/05/17/Java%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/05/17/Java%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>1、进程：程序的执行过程<br>2、线程：一个进程可以有单个线程也就是我们说的单线程，还可以有多个线程也就是我们说的多线程，</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>1、当一个类继承了Thread类就可以当成一个线程用<br>2、我们会重写run方法写上我们自己的业务逻辑<br>3、run Thread类实现了RUnnable接口,静态代理模式</p><blockquote><p>创建一个线程为什么是start不是直接调用run方法，如果直接调用run方法并没有创建一个线程，而是串行执行，start方法中的start0方法创建一个线程是由本地方法，是由JVM调用的</p></blockquote><p>当一个类他已经继承了其他类，但是我们还想让其作为线程使用的话就可以让其实现Runable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threaduse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">//没有start方法</span></span><br><span class="line">        <span class="comment">//cat.start();</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(cat);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小狗汪汪叫hi &quot;</span> + (++ cnt) + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">10</span>)   <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多个子线程案例"><a href="#多个子线程案例" class="headerlink" title="多个子线程案例"></a>多个子线程案例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> threaduse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">T1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T1</span>();</span><br><span class="line">        <span class="type">T2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T2</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t2);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world &quot;</span> + (++cnt));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">10</span>)   <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hi &quot;</span> + (++cnt));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">10</span>)   <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟售票</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ticket;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用多线程模拟三个窗口同时售票</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTicket01</span> <span class="variable">sellTicket01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket01</span>();</span><br><span class="line">        <span class="type">SellTicket01</span> <span class="variable">sellTicket011</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket01</span>();</span><br><span class="line">        <span class="type">SellTicket01</span> <span class="variable">sellTicket012</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket01</span>();</span><br><span class="line">        sellTicket012.start();</span><br><span class="line">        sellTicket011.start();</span><br><span class="line">        sellTicket01.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用继承Thread</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTicket01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;售票结束...&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//休眠50ms</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">&quot;售出一张票&quot;</span> + <span class="string">&quot;剩余票数 = &quot;</span> + (-- num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现问题</p><p><img src="https://s2.loli.net/2023/05/15/Wp98RnQ1KbL7xrY.png" alt="2.png"><br>票重复卖<br><img src="https://s2.loli.net/2023/05/15/9CbVMdmwku7Kiar.png" alt="3.png"></p><blockquote><p>这里先提出问题后续会解决啦</p></blockquote><h1 id="通知线程退出"><a href="#通知线程退出" class="headerlink" title="通知线程退出"></a>通知线程退出</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exit_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_Exit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//如果我们希望main线程去控制t线程的终止，必须可以修改loop-&gt;通知方式</span></span><br><span class="line">        <span class="comment">//休眠10s</span></span><br><span class="line">        Thread.sleep(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">        t.setLoop(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置一个变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(loop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;T还在运行&quot;</span> + (++ cnt));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoop</span><span class="params">(<span class="type">boolean</span> loop)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h1><h2 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h2><p>1、start会调用run方法并且会创建一个新线程而单独调用run方法并不会创建新线程<br>2、interrupt，中断线程一般用于结束正在休眠的线程<br>3、sleep线程的休眠<br>3、现成的优先级<br>MAX、MIN、NORM</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.awt.windows.ThemeReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMethod01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        t.setName(<span class="string">&quot;阿杜&quot;</span>);</span><br><span class="line">        t.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(t.getName());</span><br><span class="line">        <span class="comment">//主线程打印5个hi，然后就中断子线程的休眠</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;hi&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; ++ i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//Thread.currentThread().getName()获取当前线程的名称</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;吃包子~~~~~&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;休眠中~~~~~&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//InterruptedException捕获到一个中断异常</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;被 interrupt了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程插队"><a href="#线程插队" class="headerlink" title="线程插队"></a>线程插队</h1><p>yield：线程的礼让，让出cpu让其他线程先执行，让出的时间不确定，所以也不一定能成功让出<br>join：线程的插队，插队一旦成功，就一定会先执行完插队的进程<br>join方法调用的是对方的，也就是你想让插队的那个线程的<br><em>例题</em><br><img src="https://s2.loli.net/2023/05/16/xvftLN9aY5prM3u.png" alt="2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMethodExercise</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">T3</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T3</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t3);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hi &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                thread.start();</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello &quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/16/PdR1KpqD3T8ukeE.png" alt="1.png"></p><h1 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h1><p>用户线程：也叫工作线程，当线程的任务执行完或以通知的形式结束<br>守护线程：一般是为用户线程工作的，当所有用户线程结束守护线程自动结束<br>常见的守护线程：垃圾回收机制<br><img src="https://s2.loli.net/2023/05/16/uKAXUcry6xEndH7.png" alt="3.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMethod03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyDaemonThread</span> <span class="variable">myDaemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyDaemonThread</span>();</span><br><span class="line">        <span class="comment">//我们希望当主线程结束后子线程能自动结束，我们需要将子线程设置为守护线程</span></span><br><span class="line">        myDaemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        myDaemonThread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;阿杜在辛苦的工作&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDaemonThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;阿杜和阿范一直在聊天~~~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/16/u6mVtJbTz2lQxSK.png" alt="4.png"></p><h1 id="线程的七大状态"><a href="#线程的七大状态" class="headerlink" title="线程的七大状态"></a>线程的七大状态</h1><p><img src="https://s2.loli.net/2023/05/17/uMCbEdArQRDNShe.png" alt="6.png"><br><img src="https://s2.loli.net/2023/05/17/mKIcF1lqaUOpofj.png" alt="5.png"></p><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>在多线程中，对一些敏感数据可能同一时刻只允许一个线程访问，为了保证数据的完整性，任何同一时刻我们都只让一个线程访问<br>==synchronized==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SellTicket03</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;售票结束。。。。&quot;</span>);</span><br><span class="line">            loop = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(loop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;售票结束...&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//休眠50ms</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;窗口 &quot;</span> + Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">&quot;售出一张票&quot;</span> + <span class="string">&quot;剩余票数 = &quot;</span> + (-- num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用多线程模拟三个窗口同时售票</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SellTicket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SellTicket03</span> <span class="variable">sellTicket03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket03</span>();</span><br><span class="line">        <span class="type">SellTicket03</span> <span class="variable">sellTicket031</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SellTicket03</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket03);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(sellTicket031);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>上面的同步机制就是利用了锁，当多个线程运行时，他们先争夺锁，只有获得锁的线程才能执行方法，上面的售卖票利用的就是互斥锁<br>1、java引入互斥锁的概念是为了保证共享数据的完整性<br>2、互斥锁，用关键字synchronized修饰时表明该对象在任何同一时刻只能有一个线程访问<br>3、同步之后因为同一时刻只有一个线程在执行，所以效率自然会降低<br>4、如果锁加在方法上，如果方法是静态的，锁加在类上，如果方法是非静态的，锁加在当前对象（this）上或则其他对象上（并不是很理解呜呜呜~~~~~）</p><blockquote><p>互斥锁想要起作用，多个线程锁的对象必须是同一个</p></blockquote><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>双方都需要当前对方所拥有的锁资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadLockDemo</span> <span class="variable">deadLockDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLockDemo</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">DeadLockDemo</span> <span class="variable">deadLockDemo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadLockDemo</span>(<span class="literal">true</span>);</span><br><span class="line">        deadLockDemo1.start();</span><br><span class="line">        deadLockDemo.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeadLockDemo</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入了o1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o2)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入了o2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入了o2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (o1)</span><br><span class="line">                &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入了o1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/17/EtZi5p1mdUIfF24.png" alt="1.png"></p><h1 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h1><p>释放锁<br><img src="https://s2.loli.net/2023/05/17/btPsMV16dzu9FlC.png" alt="2.png"><br>不会释放锁<br><img src="https://s2.loli.net/2023/05/17/37PNBbOTtJyaksc.png" alt="3.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 843 (Div. 2)B</title>
      <link href="/2023/05/13/843-div2/"/>
      <url>/2023/05/13/843-div2/</url>
      
        <content type="html"><![CDATA[<h1 id="B-Gardener-and-the-Array"><a href="#B-Gardener-and-the-Array" class="headerlink" title="B. Gardener and the Array"></a><a href="https://codeforces.com/problemset/problem/1775/B">B. Gardener and the Array</a></h1><p>思路：只要找到一个c他的每一位均在除了它的集合中出现过即可</p><blockquote><p>这题T了2发，用来multiset，注意multiset大的时间复杂度是O(K + logn)k是相同元素的个数，能用map尽量用map</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;a[n + <span class="number">1</span>];</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;cnt;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">int</span> k;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">  a[i].<span class="built_in">push_back</span>(k);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; ++ j)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="type">int</span> x; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">   a[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">   cnt[x] ++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k = a[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; ++ j) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[a[i][j]] &lt; <span class="number">2</span>) <span class="keyword">break</span>; </span><br><span class="line"><span class="keyword">if</span>(j == k &amp;&amp; cnt[a[i][j]] &gt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span>(t --) <span class="built_in">solve</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 148A~C</title>
      <link href="/2023/05/13/148-div2/"/>
      <url>/2023/05/13/148-div2/</url>
      
        <content type="html"><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a><a href="https://codeforces.com/contest/1832/problem/A">A</a></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">60</span>;</span><br><span class="line"><span class="type">char</span> c[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">strlen</span>(c + <span class="number">1</span>);</span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;st;</span><br><span class="line">st[c[<span class="number">1</span>]] ++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / <span class="number">2</span>; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(st.<span class="built_in">find</span>(c[i]) == st.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="B"></a><a href="https://codeforces.com/contest/1832/problem/B">B</a></h1><p>直接枚举即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">LL s[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">2</span> * (k - i), r = n - i;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, s[r] - s[l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C"></a><a href="https://codeforces.com/contest/1832/problem/C">C</a></h1><p>C比赛时没出，思路上没什么大问题，就是差一点（bushi，说到底还是自己菜）<br>我们可以发现这道题只需要找一下有多少个波峰和波谷就可以了，因为波峰波谷一定不能删除</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]); </span><br><span class="line">n = <span class="built_in">unique</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>(); </span><br><span class="line"><span class="type">int</span> ans  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span> || i == n <span class="number">-1</span> || a[i] &gt; a[i - <span class="number">1</span>] == a[i] &gt; a[i + <span class="number">1</span>])ans ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库的完整性</title>
      <link href="/2023/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
      <url>/2023/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="完整性概述"><a href="#完整性概述" class="headerlink" title="完整性概述"></a>完整性概述</h1><p>数据库的完整性是指数据库的正确性、一致性、相容性<br>正确性：数据库的数据符合语义约束<br>一致性：数据间的逻辑关系是正确的，从一个一致性状态转移到另一个一致性状态<br>相容性：同一事物的两个数据应当是一致的<br>约束的分类</p><p>从约束的状态分类：<br>可以分为静态约束和动态约束<br>静态约束：数据库正确状态的约束<br>动态约束：数据库从一种正确状态转移到另一种状态的约束</p><h1 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h1><p>关系的主码唯一并且不能取空值<br>会破坏实体完整性的几种操作<br>1、向表中插入新元组会破坏实体完整性<br>2、修改元组的主码可能破坏实体完整性<br>3、违约处理，DBMS自动检查并且拒绝所有导致破坏实体完整性的任何插入和修改</p><h1 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h1><p>参照完整性是对外码取值的约束<br>外码的取值要么是其参照的表的主码的取值要么是空值（外码建立了不同关系的联系）<br>破坏参照完整性的几种情况<br>1、向参照关系中插入新元组<br>2、删除被参照关系中的元组<br>3、修改参照关系外码上的值<br>4、修改被参照关系上主码的值<br>违约处理：<br>1、拒绝<br>2、置空值<br>3、置默认值<br>4、级联<br><img src="https://s2.loli.net/2023/05/11/UbOkhSJRTpr65qi.png" alt="2.png"></p><h1 id="用户自定义的完整性"><a href="#用户自定义的完整性" class="headerlink" title="用户自定义的完整性"></a>用户自定义的完整性</h1><p>实体完整性和参照完整性是所有关系都必须遵守的，被称为关系的不变性<br>用户自定义的完整性可以分为属性级的、关系级的、数据库级的</p><h2 id="属性级的"><a href="#属性级的" class="headerlink" title="属性级的"></a>属性级的</h2><p>定义在列级上的属性约束CHECK约束、NULL约束、UNIQUE约束<br><img src="https://s2.loli.net/2023/05/11/cAjCsTNqyFKhoS1.png" alt="3.png"></p><h2 id="关系级的"><a href="#关系级的" class="headerlink" title="关系级的"></a>关系级的</h2><p>表级上的CHECK约束，涉及多个属性<br><img src="https://s2.loli.net/2023/05/11/eRMJrGX91atVOfk.png" alt="4.png"></p><h2 id="数据库级的"><a href="#数据库级的" class="headerlink" title="数据库级的"></a>数据库级的</h2><p>涉及多个关系的约束被称为数据库级的约束<br>断言Assertion是一种命名约束，他表达了数据库必须满足的逻辑状态</p><h3 id="断言的创建"><a href="#断言的创建" class="headerlink" title="断言的创建"></a>断言的创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span> <span class="keyword">CHECK</span> (<span class="operator">&lt;</span>约束条件<span class="operator">&gt;</span>) [<span class="operator">&lt;</span>约束性质<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><p>约束条件可以是涉及数据库对象的布尔表达式也可以是SELECT语句<br>约束性质可以是NOT DEEDERRABLE(不可延迟的)或DEEDERRABLE(可延迟的)，缺省时为不可延迟的（也就是说是约束立即检查）<br>eg：<br><img src="https://s2.loli.net/2023/05/11/PXYQKI7nrWOpvgJ.png" alt="5.png"><br>约束“任何部门经理的工资不超过其所在部门平均工资的10倍”涉及上述两个关系，可以为它创建一个断言，该约束等价于不存在一个部门经理，他的工资高于他所在部门平均工资的10倍“</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION SalaryConstraint <span class="keyword">CHECK</span></span><br><span class="line">(<span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> Departments D, Employeess E</span><br><span class="line"><span class="keyword">WHERE</span> D.Mrgno <span class="operator">=</span> E.Eno <span class="keyword">AND</span></span><br><span class="line">Salary <span class="operator">&gt;</span> <span class="number">10</span> <span class="operator">*</span>(<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Salary)</span><br><span class="line"><span class="keyword">FROM</span> Employees</span><br><span class="line"><span class="keyword">WHERE</span> Dno <span class="operator">=</span> D.Dno)))</span><br></pre></td></tr></table></figure><p>断言被创建后，只有不违背断言的数据库更新才被允许，如果我们修改经理的工资，只有在满足上述断言，即工资不超过该部门平均工资的10倍的情况下才允许被更新</p><h3 id="断言的删除"><a href="#断言的删除" class="headerlink" title="断言的删除"></a>断言的删除</h3><p>如果没有其他数据库对象的定义依赖断言可用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span> <span class="operator">&lt;</span>触发时间<span class="operator">&gt;</span> <span class="operator">&lt;</span>触发事件<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">REFERENCING</span> <span class="operator">&lt;</span>旧<span class="operator">/</span>新值别名<span class="operator">&gt;</span>. ...., <span class="operator">&lt;</span>旧<span class="operator">/</span>新值别名<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">FOR</span> <span class="keyword">EACH</span>&#123;<span class="type">ROW</span> <span class="operator">|</span> STATEMENT&#125;]</span><br><span class="line">[<span class="keyword">WHEN</span>(<span class="operator">&lt;</span>触发条件<span class="operator">&gt;</span>)]</span><br><span class="line"><span class="operator">&lt;</span>被触发的<span class="keyword">SQL</span>语句<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>REFERENCING子句创建一些过渡变量用来存放表T和表T的行更新前的旧值和更新后的新值。</p></blockquote><p>&lt;旧/新值别名&gt;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OLD</span> [<span class="type">ROW</span>] [<span class="keyword">AS</span>] <span class="operator">&lt;</span>变量<span class="operator">&gt;</span>:创建行过渡变量<span class="operator">&lt;</span>变量<span class="operator">&gt;</span>存放表T的行更新前的旧值</span><br><span class="line"><span class="keyword">NEW</span> [<span class="type">ROW</span>] [<span class="keyword">AS</span>] <span class="operator">&lt;</span>变量<span class="operator">&gt;</span>:创建行过渡变量<span class="operator">&lt;</span>变量<span class="operator">&gt;</span>存放表T的行更新后的新值</span><br><span class="line"><span class="keyword">OLD</span> <span class="keyword">TABLE</span> [<span class="keyword">AS</span>] <span class="operator">&lt;</span>变量<span class="operator">&gt;</span>:创建表过渡变量<span class="operator">&lt;</span>变量<span class="operator">&gt;</span>存放表T的行更新前的旧值</span><br><span class="line"><span class="keyword">NEW</span> <span class="keyword">TABLE</span> [<span class="keyword">AS</span>] <span class="operator">&lt;</span>变量<span class="operator">&gt;</span>:创建表过渡变量<span class="operator">&lt;</span>变量<span class="operator">&gt;</span>存放表T的行更新前的新值</span><br></pre></td></tr></table></figure><p>FOR EACH ROW:定义行级触发器<br>FOR EACH STATRMENT：定义语句级触发器</p><p>WHEN子句定义触发条件缺省时为无条件触发<br>&lt;被触发的SQL语句&gt;<br>形式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line"><span class="operator">&lt;</span>可执行的<span class="keyword">SQL</span>语句<span class="operator">&gt;</span>;</span><br><span class="line"><span class="operator">&lt;</span>可执行的<span class="keyword">SQL</span>语句<span class="operator">&gt;</span>;</span><br><span class="line"><span class="operator">&lt;</span>可执行的<span class="keyword">SQL</span>语句<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>删除触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟存储器</title>
      <link href="/2023/05/10/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/05/10/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>虚拟存储器是==主存-辅存==层次的，虚拟存储器主要是由操作系统实现，在计算机组成原理中应更加关注主存-Cache</p><h1 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h1><h2 id="1、实地址与虚地址"><a href="#1、实地址与虚地址" class="headerlink" title="1、实地址与虚地址"></a>1、实地址与虚地址</h2><p>1、实地址（物理地址）：计算机物理内存的访问地址。<br>2、虚地址（逻辑地址）：用户编程时使用的地址。<br>3、再定位：程序进行虚地址到实地址转换的过程。<br>4、虚地址空间与实地址空间的关系<br>虚地址空间可以远大于实地址空间，这时可以提高存储容量<br>虚地址空间可以远小于实地址空间，这时可以缩短指令值地址字段的长度</p><blockquote><p>虚拟存储器是概念模型不是实际的存储器</p></blockquote><h2 id="2、虚存的访问过程"><a href="#2、虚存的访问过程" class="headerlink" title="2、虚存的访问过程"></a>2、虚存的访问过程</h2><p><img src="https://s2.loli.net/2023/05/10/3VX28gHLkPoh4OQ.png" alt="510.1.png"></p><h2 id="3、Cache与虚存的异同"><a href="#3、Cache与虚存的异同" class="headerlink" title="3、Cache与虚存的异同"></a>3、Cache与虚存的异同</h2><p>主存-辅存与Cache-主存的访问机制类似<br>相同点是：<br>1、出发点相同，提高性能和容量、降低成本<br>2、原理相同：都是运用局部性原理<br>不同点<br>1、侧重点：Cache解决速度问题 、虚存解决容量问题<br>2、数据通路不通：CPU与Cache有直接通路而虚存所依赖的辅存和CPU并无直接通路<br>3、透明性不同：Cache均有硬件实现，对系统程序元和应用程序员均透明虚存对系统程序员不透明，对应用程序员透明<br>4、未命中时的损失不同，主存与Cache的访问时间、以及主存与辅存的访问时间，他们相差的时间远不相同</p><h2 id="3、虚存机制要解决的问题"><a href="#3、虚存机制要解决的问题" class="headerlink" title="3、虚存机制要解决的问题"></a>3、虚存机制要解决的问题</h2><p>1、调度问题<br>2、地址映射问题<br>3、替换问题<br>4、更新问题<br><img src="https://s2.loli.net/2023/05/10/z9eJOSogBGlm8bL.png" alt="510.2.png"></p><h1 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h1><p>首先我们要清楚页是什么？页是主存物理空间划分出来的等长区域又称页面，好了现在我们清楚了页的概念可以继续看下去。<br>那么什么叫页式管理呢？页式管理是对存储-辅存系统间采取的是以页为单位的信息传送<br>这种管理方式有他的优点和缺点，首先我们先看他的优点，优点是什么的？我们思考，这样分成一整块我们构造页表比较容易这样可以方便我们的管理，除了最后一页外，我们也没有浪费空间。<br>缺点其实也显而易见就是，因为分页是按空间大小分的，同一程序可能被分到两个或多个页内，不利于编程的独立性</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1、以页为基本单位构造出来的虚拟存储器称为页式虚拟存储器<br>2、逻辑页：虚地址空间被分成的页<br>3、物理页：实地址空间被分成同样大小的页<br><img src="https://s2.loli.net/2023/05/10/VtMPoNJHbfmG1uc.png" alt="510.3.png"></p><h2 id="页式虚存地址映射"><a href="#页式虚存地址映射" class="headerlink" title="页式虚存地址映射"></a>页式虚存地址映射</h2><p>虚地址和实地址之间的地址映射是通过页表来实现的<br>页表如下图所示：<br><img src="https://s2.loli.net/2023/05/10/lLI7M9tvXF6xDBe.png" alt="510.4.png"><br>虚拟地址的映射过程如下：<br>页表的基地址被存在一个寄存器中，我们通过虚存地址的逻辑页号以及页表基地址索引找到虚存地址页对应的物理页，然后物理页（作为实存地址的高字段）加上虚存地址的页内地址就是实存地址。<br><img src="https://img2023.cnblogs.com/blog/3012367/202305/3012367-20230510161416827-1430205353.png" alt="image"></p><h2 id="内页表和外页表"><a href="#内页表和外页表" class="headerlink" title="内页表和外页表"></a>内页表和外页表</h2><p>页表分为内页表和外页表<br>内页表：虚存和主存之间地址变换的表<br>外页表：虚存和辅存之间地址变换的表<br>主存缺页式要先定位到辅存</p><h2 id="转换后援缓冲器（TLB）"><a href="#转换后援缓冲器（TLB）" class="headerlink" title="转换后援缓冲器（TLB）"></a>转换后援缓冲器（TLB）</h2><p>1、把页表中最活跃的部分调入高速缓冲器<br>2、TLB是快表，而存放在主存中的完整页表被称为慢表</p><blockquote><p>TLB的作用类似与CPU主存之间的Cache<br><img src="https://s2.loli.net/2023/05/10/tZ8NnTAP75m9dg6.png" alt="510.6.png"></p></blockquote><h2 id="虚拟存储器、TBL、Cache的协同操作"><a href="#虚拟存储器、TBL、Cache的协同操作" class="headerlink" title="虚拟存储器、TBL、Cache的协同操作"></a>虚拟存储器、TBL、Cache的协同操作</h2><p>最好的情况是TBL命中，Cache也命中<br><img src="https://s2.loli.net/2023/05/10/RpXnEQI95fTxhHO.png" alt="510.7.png"></p><h1 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>1、段：按照程序的自然分界划分的长度可以动态改变的区域<br>2、段的优点：便于编译、管理修改和保护，段长可变，便于有效利用主存空间<br>3、缺点：主存分配空间比较麻烦，容易产生碎片空间</p><h2 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h2><p>通过段表<br><img src="https://s2.loli.net/2023/05/10/ektSDMHPFE8oxOz.png" alt="510.8.png"><br>段表的每个段表项至少包含以下3项<br>（1）、有效位<br>（2）、段起址<br>（3）、段长<br>段表图示如下：<br><img src="https://s2.loli.net/2023/05/10/iX71Egs4l5eMofN.png" alt="510.9.png"><br>虚地址映射过程如下：<br><img src="https://s2.loli.net/2023/05/10/17Srzg5UEFNIYn4.png" alt="510.10.png"></p><h1 id="段页式虚拟存储器（套娃）"><a href="#段页式虚拟存储器（套娃）" class="headerlink" title="段页式虚拟存储器（套娃）"></a>段页式虚拟存储器（套娃）</h1><p>段页式虚拟存储器是把程序按逻辑结构分段，每段再划分为固定大小的页<br>主存空间也划分为大小相等的页<br>每个程序对应一个段表，每段对应一个页表</p><blockquote><p>虚拟地址：段号+段内页号+页内地址</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/kdKJxaMDPyRQZBb.png" alt="510.11.png"><br><img src="https://s2.loli.net/2023/05/10/lFU3xKe5npECXqw.png" alt="510.12.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句</title>
      <link href="/2023/05/10/SQL%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/05/10/SQL%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="创建基本表"><a href="#创建基本表" class="headerlink" title="创建基本表"></a>创建基本表</h1><p>创建基本表要对表进行命名，定义表的每个列，定义表的完整性约束条件，我们使用CREATE TABLE语句创建基本表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [DEEAULT<span class="operator">&lt;</span>缺省值<span class="operator">&gt;</span>] [列级约束定义],</span><br><span class="line"><span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [DEEAULT<span class="operator">&lt;</span>缺省值<span class="operator">&gt;</span>] [列级约束定义],</span><br><span class="line"><span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [DEEAULT<span class="operator">&lt;</span>缺省值<span class="operator">&gt;</span>] [列级约束定义],</span><br><span class="line">...,</span><br><span class="line">[<span class="operator">&lt;</span>表级约束定义<span class="operator">&gt;</span>],...,<span class="operator">&lt;</span>表级约束定义<span class="operator">&gt;</span>);</span><br></pre></td></tr></table></figure><p>1、表名、列名均是由我们自己去定义的<br>2、数据类型即sql语言中给定的几种数据类型<br>3、缺省值是以后我们向数据库该的表中插入元素时，假如我们空缺了这一项，就会填上我们设置的缺省值<br>4、列级约束定义是对当前列的约束条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span>] <span class="operator">&lt;</span>列约束<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>列约束包括以下几种：<br>NOT NULL：不允许该列取空值；不加NOT NULL限制时，该列可以取空值<br>PRIMARYKEY：指明该列为主码，其值非空、唯一<br>UNIQUE：该列上的值唯一，说明改列为候选码<br>CHECK(&lt;条件&gt;)：指明该列的值必须满足的条件，&lt;条件&gt;为一个bool表达式</p></blockquote><h1 id="排序和分组"><a href="#排序和分组" class="headerlink" title="排序和分组"></a>排序和分组</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>ORDER BY子句可以将查询结果按一定的次序显示.<br>形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>排序列<span class="operator">&gt;</span> [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]&#123;, <span class="operator">&lt;</span>排序列<span class="operator">&gt;</span> [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]&#125;</span><br></pre></td></tr></table></figure><p>1、&lt;排序列&gt;是必须出现在SELECT语句中的属性名。<br>2、ORDER BY语句可以有一个或多个排序列，中间用逗号隔开。每个排序列都可以单独指定升序还是降序排列，==缺省==时为升序。<br>查询每位学生的每门课程的成绩，按成绩降序排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="operator">=</span> <span class="string">&#x27;CS202&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Grade <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>3、聚集函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">统计元组个数</span><br><span class="line"><span class="built_in">COUNT</span>([<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>]<span class="operator">*</span>)</span><br><span class="line">统计一列中值的个数</span><br><span class="line">COUNT（[<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] 列名）</span><br><span class="line">计算一列中值的个数</span><br><span class="line"><span class="built_in">SUM</span>([<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] 列名)</span><br><span class="line"><span class="built_in">AVG</span>([<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] 列名)</span><br><span class="line"><span class="built_in">MAX</span>([<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] 列名)</span><br><span class="line"><span class="built_in">MIN</span>([<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] 列名)</span><br></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>分组的关系和聚集函数的关系很大<br>GROUP BY语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span><span class="operator">&lt;</span>分组列<span class="operator">&gt;</span>[<span class="keyword">HAVING</span> <span class="operator">&lt;</span>分组选择条件<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>分组语句细化了聚集函数的作用范围<br>HAVING短语用来过滤掉不满足的&lt;分组选择条件&gt;的分组,缺省时等价于HAVING TRUE<br>&lt;分组选择条件&gt;类似于WHERE子句的查询条件，只不过WHERE子句中不允许出现聚集函数</p></blockquote><p>eg：查询每个学生的平均成绩，并输出平均成绩大于85的学生的学号和平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, <span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno <span class="keyword">HAVING</span> <span class="built_in">AVG</span>(Grade) <span class="operator">&gt;</span> <span class="number">85</span>;</span><br></pre></td></tr></table></figure><p>对于带GROUP BY子句的SELECT语句，SELECT子句中的结果列必须是GROUP BY子句中的&lt;分组列&gt;或聚集函数。</p><h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><p>Q:查询阿杜选修数据库系统原理课程的成绩？</p><blockquote><p>当查询需要的信息或者查询条件涉及的属性分布在多个表中时，需要进行链接查询</p></blockquote><p>1、SQL支持连接查询，允许FROM子句中包括多个表<br>2、当FROM子句中包含多个表时，相当于求这些表的笛卡尔积<br>3、可以在WHERE子句中说明连接条件，并通过SELECT子句选取所需要的属性来实现各种连接<br>eg:查询学号为201705001的学生的各科成绩，对每门课程显示课程名和成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Cname, Grade</span><br><span class="line"><span class="keyword">FROM</span> SC, Course</span><br><span class="line"><span class="keyword">WHERE</span> SC.Cno <span class="operator">=</span> Course.Cno <span class="keyword">AND</span> Sno <span class="operator">=</span> <span class="string">&#x27;2017050001&#x27;</span></span><br></pre></td></tr></table></figure><p>eg:查询每个学生的平均成绩，并输出平均成绩大于85的学生的学号、姓名和平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, <span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC, Students</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno, Sname</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(Grade) <span class="operator">&gt;</span> <span class="number">85</span>;w</span><br></pre></td></tr></table></figure><h1 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h1><p>SQL是一种结构化查询语言，他允许将一个查询作为子查询嵌套在另一个SELECT语句中</p><blockquote><p>比较常见的嵌套是将查询结果嵌套在WHERE或HAVING语句中，子查询不能用ORDER BY语句，只有最终查询结果才能用ORDEFR BY语句</p></blockquote><h2 id="IN引出的子查询"><a href="#IN引出的子查询" class="headerlink" title="IN引出的子查询"></a>IN引出的子查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>元组<span class="operator">&gt;</span>[<span class="keyword">NOT</span>]<span class="keyword">IN</span><span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>eg：查询和林艳在同一专业学习的女同学的学号和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Sex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">AND</span> Speciality <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line">SELCET Speciality</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="operator">=</span> <span class="string">&#x27;林艳&#x27;</span>)；</span><br></pre></td></tr></table></figure><p>下面是先找到林艳的专业，然后将此专业作为查询条件</p><h1 id="集合的比较引出的查询"><a href="#集合的比较引出的查询" class="headerlink" title="集合的比较引出的查询"></a>集合的比较引出的查询</h1><p>SQL语言允许将一个元素与子查询的结果集进行比较。<br>形式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>值表达式<span class="operator">&gt;</span> Θ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">SOME</span> <span class="operator">|</span> <span class="keyword">ANY</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>其中&lt;值表达式&gt;通常是属性，Θ是比较运算符。SOME与ANY含义相同。早期只有ANY但是和英语上的any容易混淆，现在多用SOME。当&lt;子查询&gt;的结果为单个值时，ALL、SOME和ANY可以省略。<br>eg：<br>查询比软件工程专业所有学生都小的其他专业的学生的学号、姓名、专业和出生日期</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname, Speciality, <span class="keyword">year</span>(BIrthday)</span><br><span class="line"><span class="keyword">From</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Speciality <span class="operator">&lt;&gt;</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span>(Birthday) <span class="operator">&gt;</span> <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> <span class="keyword">year</span> (Birthday)</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Speciality <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>ALL 可以与聚集函数实现的查询互换</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname, Speciality, <span class="keyword">year</span>(Birthday)</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Speciality<span class="operator">&lt;&gt;</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">AND</span> </span><br><span class="line"><span class="keyword">year</span>(Birthday) <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(<span class="keyword">year</span>(Birthday)))</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Speciality <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/09/cpmd3PCs6yE7WV2.png" alt="image"></p><h1 id="存在量词引导的子查询"><a href="#存在量词引导的子查询" class="headerlink" title="存在量词引导的子查询"></a>存在量词引导的子查询</h1><p>形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXISTS</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">子查询的<span class="keyword">SELECT</span>子句的形式为<span class="keyword">SELECT</span><span class="operator">*</span>。<span class="keyword">EXISTS</span><span class="operator">&lt;</span>子查询<span class="operator">&gt;</span>为真，当且仅当<span class="operator">&lt;</span>子查询<span class="operator">&gt;</span>的结果非空（至少包含一个元组）</span><br></pre></td></tr></table></figure><blockquote><p>EXISTST是根据外层查询的每个元组依次取与内层查询的结果比较看是否为空，若非空则为真输出，反之则不输出，这是一个相关子查询。<br>这里我们可以把查询分为两种，一种是相关子查询，一种是不相关子查询。相关子查询就是内层查询依赖于外层查询，不相关子查询就是外层查询不依赖于内层查询</p></blockquote><p>感觉NOT EXISTS这里很绕还没有搞清楚，搞清楚再回来补这一点的内容和例子</p><h1 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>1、向基本表中插入单个元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T [(A1, ..., Ak)] <span class="keyword">VALUE</span>(c1, ..., ck)</span><br></pre></td></tr></table></figure><p>eg:<br>向Students表中添加一条这样的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Students</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;201716010&#x27;</span>, <span class="string">&#x27;司马相如&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">1997</span><span class="number">-01</span><span class="number">-28</span>, <span class="string">&#x27;2017&#x27;</span>, <span class="string">&#x27;计算数学&#x27;</span>, <span class="string">&#x27;MATh&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>A1，A2…可以不按顺序，只要与下面的值对应就可以，A1，A2等也可以省略，但这是下面的内容则必须按顺序</p></blockquote><p>2、插入查询结果<br>想基本表中插入单个元组一般用于数据的输入，我们有时候还想将查询结果插入到一个基本表中。插入查询结果的语句的基本形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T [(A1, A2, ..., Ak)]</span><br><span class="line"><span class="operator">&lt;</span>查询表达式<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>T通常是基本表，也可以是视图， A1，…,Ak是T的属性，&lt;查询表达式&gt;通常是一个SELECT语句</p></blockquote><p>eg:<br>信息工程学院要为本院每位教师办理一个校内就餐卡，直接用教师号作为主持人的编号，并预存100元，可以用INSERT语句插入到基本表中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Cardinf(Card<span class="operator">-</span><span class="keyword">no</span>, Name, Balance)</span><br><span class="line"><span class="keyword">SELECT</span> Tno, Tname, <span class="number">100.00</span></span><br><span class="line"><span class="keyword">FROM</span> Teachers</span><br><span class="line"><span class="keyword">WHERE</span> Dno <span class="operator">=</span> <span class="string">&#x27;IE&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意常量100.00出现在SELECT中。这使得查询结果的每个元组的第3列均取常量100.00。</p></blockquote><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>UPDATE语句格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> T</span><br><span class="line"><span class="keyword">SET</span> A1 <span class="operator">=</span> e1, ..., Ak <span class="operator">=</span> ek</span><br><span class="line">[<span class="keyword">WHERE</span><span class="operator">&lt;</span>修改条件<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><p>其中T通常是基本表，但也可以是某些视图，A1，…,Ak<br>是T的属性，而e1，…,ek是表达式,&lt;删除条件&gt;与SELECT语句中的查询条件类似</p><p>eg：将职工号为B050041的教师的职称修改为副教授</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Teachers</span><br><span class="line"><span class="keyword">SET</span> Title <span class="operator">=</span> <span class="string">&#x27;副教授&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Tno <span class="operator">=</span> <span class="string">&#x27;B050041&#x27;</span>;</span><br></pre></td></tr></table></figure><p>eg:将软件工程课程成绩低于60分的所有学生的软件工程成绩提高5分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> SC</span><br><span class="line"><span class="keyword">SET</span> Grade <span class="operator">=</span> Grade <span class="operator">+</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="operator">&lt;</span> <span class="number">60</span> <span class="keyword">AND</span> Cno <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> Cno</span><br><span class="line"><span class="keyword">FROM</span> Course </span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>当关系表中的某些记录已经不再需要时，可以使用DELETE语句进行删除。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> T</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>删除条件<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><p>T通常是基本表，但也可以是某些视图<br>&lt;删除条件&gt;与SELECT语句中的查询条件</p><p>eg：删除学号为201824010的学生的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> <span class="string">&#x27;201824010&#x27;</span></span><br></pre></td></tr></table></figure><p>eg:删除所有的学生的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Students</span><br></pre></td></tr></table></figure><blockquote><p>没有WHERE语句时条件恒真</p></blockquote><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图是从一个或多个基本表或视图导出的表，与基本不同的是视图的数据并不物理地存放在基本表中</p><h2 id="视图的创建和删除"><a href="#视图的创建和删除" class="headerlink" title="视图的创建和删除"></a>视图的创建和删除</h2><h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><p>形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>， ...,<span class="operator">&lt;</span>(列名)<span class="operator">&gt;</span>)]</span><br><span class="line"><span class="keyword">AS</span><span class="operator">&lt;</span>查询表达式<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure><p>&lt;视图名&gt;:标识符，我们自己命名<br>&lt;(列名)&gt;：&lt;查询表达式&gt;结果的诸列<br>&lt;查询表达式&gt;：通常是一个SELECET语句不包含DISTINCT短语和ORDER BY子句<br>[WITH CHECK OPTION]：表示该视图是可更新的<br>eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> SE_Students</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> Sno, Sname, Sex, Birthday, Dno</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Speciality <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></table></figure><blockquote><p>组成视图的属性列名要么全部省略要么全部指定。如果省略了视图的各个属性名，则有SELECT子句目标列中的各个字段组成。但在下列情况下必须明确指定组成视图的所有属性列名：<br>1、SELECT目标列中包含聚集函数或者列表达式<br>2、SELECT子句目标是’*’<br>3、多表连接时出现了同名属性列<br>4、需要为视图中某个列定义更合适的名字</p></blockquote><p>eg:建立软件工程专业学生的视图SE_Students,它包含Students中出Speciality之外的所有属性和软件工程专业所有学生的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> SE_Students</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> Sno, Sname, Sex, Birthday, Dno</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Speciality <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></table></figure><p>eg：基于多个表的视图<br>建立学生成绩视图Students_Grades,它包含如下属性：学号、学生姓名、课程名和成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Students_Grades(Sno, Sname, Cname, Grade)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> S.Sno, Sname, Cname, Grade</span><br><span class="line"><span class="keyword">FROM</span> Students S, SC, Courses C</span><br><span class="line"><span class="keyword">WHERE</span> S.Sno <span class="operator">=</span> SC.Sno <span class="keyword">AND</span> C.Cno <span class="operator">=</span> SC.Cno;</span><br></pre></td></tr></table></figure><h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><p>格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [CASCADE <span class="operator">|</span> RESTRICT]</span><br></pre></td></tr></table></figure><p>删除视图就是把视图的定义从数据字典中删除</p><h2 id="基于视图的查询"><a href="#基于视图的查询" class="headerlink" title="基于视图的查询"></a>基于视图的查询</h2><p>我们可以对视图进行查询，但最后都会消解为对基本表的查询<br>eg：查询软件工程专业的男生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SE_Students</span><br><span class="line"><span class="keyword">WHERE</span> Sex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line">上面的语句等价于下面的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>(<span class="keyword">SELECT</span> Sno, Sname, Sex, Birthday, Dno</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line">WGERE Speciality <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>)</span><br><span class="line"><span class="keyword">AS</span> SE_Students(Sno, Sname, Sex, Birthday, Dno)</span><br><span class="line"><span class="keyword">WHERE</span> Sex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="基于视图的更新"><a href="#基于视图的更新" class="headerlink" title="基于视图的更新"></a>基于视图的更新</h2><p>视图有可更新视图和不可更新视图<br>一般情况下行列子集视图都可以更新<br>eg：向软件工程专业的学生的视图SE_Students中插入一个新的记录，学号为201805109，姓名为阿杜，出生年月2023-05-10，女性，院系EI</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SE_Students(Sno, Sname, Birthday, Sex, Dno)</span><br><span class="line"><span class="keyword">VALUE</span>(<span class="string">&#x27;201805109&#x27;</span>, <span class="string">&#x27;阿杜&#x27;</span>, <span class="number">2023</span><span class="number">-05</span><span class="number">-10</span>,<span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;EI&#x27;</span>)</span><br></pre></td></tr></table></figure><p>eg；将软件工程专业学号为202105268的学生姓名改成‘李岩’</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> SE_Students</span><br><span class="line"><span class="keyword">SET</span> Sname <span class="operator">=</span> <span class="string">&#x27;李岩&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> <span class="string">&#x27;201805268&#x27;</span></span><br></pre></td></tr></table></figure><p>不可更新视图<br>S_G学生的平均成绩视图，没有办法透过视图来更改</p><h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><p>1、使用视图可以使一些查询表达更加简洁<br>2、视图提供了一定的逻辑独立性<br>3、视图可以起到安全保护作用<br>4、视图使得用户可以从不同的角度看待相同的数据</p><h1 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h1><p>SQL可以嵌入到C、JAVA等其他语言中，嵌入其他语言有一些问题需要解决<br>1、如何区分两种语言<br>2、两种语言的语句如何交换信息（通信）<br>3、如何连接数据库<br>下面以C语言为例</p><h2 id="（1）、"><a href="#（1）、" class="headerlink" title="（1）、"></a>（1）、</h2><h3 id="a、扩充主语言的编译系统，使之能处理SQL语句"><a href="#a、扩充主语言的编译系统，使之能处理SQL语句" class="headerlink" title="a、扩充主语言的编译系统，使之能处理SQL语句"></a>a、扩充主语言的编译系统，使之能处理SQL语句</h3><h3 id="b、在编译前先扫描源程序，将SQL语句翻译成目标代码"><a href="#b、在编译前先扫描源程序，将SQL语句翻译成目标代码" class="headerlink" title="b、在编译前先扫描源程序，将SQL语句翻译成目标代码"></a>b、在编译前先扫描源程序，将SQL语句翻译成目标代码</h3><blockquote><p>为了区分源程序中的SQL语句和诸语言语句，SQL规定：<br>所有嵌入式SQL语句都必须加前缀EXEC SQL</p></blockquote><h2 id="（2）、"><a href="#（2）、" class="headerlink" title="（2）、"></a>（2）、</h2><h3 id="a、SQLCODE"><a href="#a、SQLCODE" class="headerlink" title="a、SQLCODE"></a>a、SQLCODE</h3><p>1、每个SQL语句执行之后需要反馈一些状态信息，系统将这些状态信息存入SQLCODE<br>2、主语言语句可以访问SQLCODE，根据结果采取相应动作<br>3、SQLCODE是一个整型变量<br>如果SQL语句执行成功，SQLCODE = 0<br>如果执行结果无数据则SQLCODE = 100<br>其他情况视为异常，SQLCODE取负值，其具体值依赖于实现</p><h3 id="b、主语言变量"><a href="#b、主语言变量" class="headerlink" title="b、主语言变量"></a>b、主语言变量</h3><p>一般情况下主语言变量不能再SQL语言中使用<br>但是使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">BEGIN</span> <span class="keyword">DECLARE</span> SECTION;</span><br><span class="line">主语言变量;</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">END</span> <span class="keyword">DECLARE</span> SECTION;</span><br></pre></td></tr></table></figure><p>可以在SQL中使用</p><blockquote><p>为了区别SQL语句中出现的的主语言变量之前必须加冒号（：）</p></blockquote><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>游标的作用：<br>一个SQL语句得到的结果可能是多个记录，而主语言没办法一次处理多个记录，这就需要用到游标。<br>游标就是一个数据缓冲区，暂时存放SQL语句的执行结果<br>使用游标需要预先说明游标，在使用前打开游标，通过专门的SQL语句逐一提取记录，并在完成之后关闭游标</p><h2 id="如何连接数据库"><a href="#如何连接数据库" class="headerlink" title="如何连接数据库"></a>如何连接数据库</h2><p>c语言</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">CONNECT</span> <span class="keyword">TO</span> <span class="operator">&lt;</span><span class="keyword">SQL</span>服务器<span class="operator">&gt;</span>[<span class="keyword">AS</span><span class="operator">&lt;</span>连接名<span class="operator">&gt;</span>][<span class="keyword">USER</span><span class="operator">&lt;</span>用户名<span class="operator">&gt;</span>];</span><br><span class="line">``</span><br><span class="line">建立到当前服务器的默认连接</span><br><span class="line">```<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQl</span> <span class="keyword">CONNECT</span> <span class="keyword">TO</span> <span class="keyword">DEFAULT</span>;</span><br></pre></td></tr></table></figure><p>关闭数据库连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> DISCONNECTION <span class="operator">&lt;</span>连接名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h1 id="不使用游标的SQL语句"><a href="#不使用游标的SQL语句" class="headerlink" title="不使用游标的SQL语句"></a>不使用游标的SQL语句</h1><p>有些SQL语句不产生结果，这些SQL语句可以不适用游标<br>说明型语句、数据定义语句、数据控制语句、SQL产生的结果不是元组的集合，主语言可以一次处理那么也不需要游标<br>（例如查询结果为单个记录的SELECT语句）、非交互的语句</p><h2 id="1、查询结果为单个记录的SELECT语句"><a href="#1、查询结果为单个记录的SELECT语句" class="headerlink" title="1、查询结果为单个记录的SELECT语句"></a>1、查询结果为单个记录的SELECT语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">SELECT</span> <span class="operator">&lt;</span>选择序列<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">INTO</span> <span class="operator">&lt;</span>选择目标序列<span class="operator">&gt;</span></span><br><span class="line">其他子句</span><br></pre></td></tr></table></figure><p>eg:查询给定学生的给定课程成绩<br>假设学生的学号已经赋予主变量Hsno，课程号已经赋值给主变量Hcno，则下面语句将检索相应的成绩，并将结果赋予主变量Hgrade：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">SELECT</span> Grade</span><br><span class="line"><span class="keyword">INTO</span>:Hgrade:igrade</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span>:Hsno <span class="keyword">AND</span> Cno <span class="operator">=</span>:Hcno;</span><br></pre></td></tr></table></figure><h2 id="非交互式更新"><a href="#非交互式更新" class="headerlink" title="非交互式更新"></a>非交互式更新</h2><p>删除一个学生的记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL DELETE FROM SC </span><br><span class="line">WHERE Sno =:Hsno;</span><br><span class="line">EXEC SQL DELETE FROM Students </span><br><span class="line">WHERE Sno =:Hsno;</span><br></pre></td></tr></table></figure><h1 id="使用游标的SQL"><a href="#使用游标的SQL" class="headerlink" title="使用游标的SQL"></a>使用游标的SQL</h1><p>使用游标的SQOL语句有如下两种情况<br>1、查询结果为多个元组的SELCET语句<br>2、交互式更新语句</p><blockquote><p>所有使用游标的SQL语句都必须先通过<br>1、说明定义游标<br>2、在使用前打开游标<br>3、反复推进游标指针并取当前记录进行处理<br>4、最后，当所有记录都处理完之后，关闭游标</p></blockquote><p>说明游标使用DECLARE语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">DECLARE</span> <span class="operator">&lt;</span>游标名<span class="operator">&gt;</span> <span class="keyword">CURSOR</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="operator">&lt;</span><span class="keyword">SELECT</span>语句<span class="operator">&gt;</span></span><br><span class="line">[<span class="operator">&lt;</span>可更新性子句<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><p>1、游标的内容由打开游标时执行定义游标的&lt;SELECT语句&gt;决定<br>2、有一个与游标相关联的指针，初始时它指向游标第一行之前的位置<br>[&lt;可更新性子句&gt;]：有两种形式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOR</span> READ <span class="keyword">ONLY</span></span><br></pre></td></tr></table></figure><p>定义只读游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOR</span> <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span>，..., <span class="operator">&lt;</span>列名<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><p>定义可更新游标</p><p>缺省时为只读型游标</p><h2 id="可更新型游标"><a href="#可更新型游标" class="headerlink" title="可更新型游标"></a>可更新型游标</h2><p>对于可更新型游标，使用CURRENT形式的UPDATE和DELETE语句进行更新，对游标的更新转换成对定义游标的基本表的更新，所以SELECT语句定义的表必须是可更新的</p><h2 id="游标的两种状态"><a href="#游标的两种状态" class="headerlink" title="游标的两种状态"></a>游标的两种状态</h2><h3 id="游标的打开"><a href="#游标的打开" class="headerlink" title="游标的打开"></a>游标的打开</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">OPEN</span> <span class="operator">&lt;</span>游标名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="关闭游标"><a href="#关闭游标" class="headerlink" title="关闭游标"></a>关闭游标</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">CLOSE</span> <span class="operator">&lt;</span>游标名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="推进游标指针并取当前记录"><a href="#推进游标指针并取当前记录" class="headerlink" title="推进游标指针并取当前记录"></a>推进游标指针并取当前记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">FETCH</span> [[<span class="operator">&lt;</span>推进方向<span class="operator">&gt;</span>] <span class="keyword">FROM</span>] <span class="operator">&lt;</span>游标名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">INTO</span>:<span class="operator">&lt;</span>主变量<span class="operator">&gt;</span>[:<span class="operator">&lt;</span>指示变量<span class="operator">&gt;</span>,...,:<span class="operator">&lt;</span>主变量<span class="operator">&gt;</span>[:<span class="operator">&lt;</span>指示变量<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>&lt;推进方向&gt;:NEXT：向前推进一个记录<br>PRIOR：向后推进一个进路<br>FIRST：推进到第一个记录<br>LAST：推进到最后一个记录<br>缺省值为NEXT<br>INTO子句中的主变量必须与说明游标中的SELECT语句中的目标列表达式一一对应</p></blockquote><h3 id="Current形式的更新语句"><a href="#Current形式的更新语句" class="headerlink" title="Current形式的更新语句"></a>Current形式的更新语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> T</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> <span class="operator">&lt;</span>游标<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> T</span><br><span class="line"><span class="keyword">SET</span> A1 <span class="operator">=</span> e1, ..., Ak <span class="operator">=</span> ek</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span><span class="operator">&lt;</span>游标名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>eg:从Students和SC中删除某学生的记录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> YN;<span class="comment">//变量YN不在SQL语句中使用</span></span><br><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line"><span class="type">char</span> Givenname[<span class="number">8</span>];</span><br><span class="line"><span class="type">char</span> Hson[<span class="number">9</span>];</span><br><span class="line"><span class="type">char</span> Hsname[<span class="number">9</span>];</span><br><span class="line"><span class="type">char</span> Hsex[<span class="number">9</span>];</span><br><span class="line"><span class="type">char</span> Henrollyear[<span class="number">9</span>];</span><br><span class="line"><span class="type">char</span> Hspeciality[<span class="number">9</span>];</span><br><span class="line"><span class="type">char</span> Hdno[<span class="number">9</span>];</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line">EXEC SQL DECLARE Stydent_Cursor CURSOR FOR </span><br><span class="line">SELECT Sno, Sname, Sex, Enrollyear, Speciality, Dno</span><br><span class="line">FROM Students</span><br><span class="line">WHERE Sname=:Givenname</span><br><span class="line">FOR UPDATE;</span><br><span class="line">Givenname=<span class="string">&#x27;李明&#x27;</span>;</span><br><span class="line">EXEC SQL OPEN Student_Cursor;</span><br><span class="line">EXEC SQL FETCH Students_Coursor;</span><br><span class="line"><span class="keyword">while</span>(SQLCODE = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s %s % s % s %是\n&quot;</span>, Hsno, Hsname, Hsex, Henrollyear, Hspeciality, Hdno);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;YN);</span><br><span class="line"><span class="keyword">if</span>(YN == <span class="string">&#x27;y&#x27;</span> || YN == <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">EXEC SQL DELETE FROM SC</span><br><span class="line">WHERE Sno = :Hsno;</span><br><span class="line">EXEC SQL DELETE FROM Students</span><br><span class="line">WHERE CURRENT OF Students_Cursor;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXEC SQL FETCH Student_Cursor</span><br><span class="line">INTO:Hsno,:Hsname,:Hsex, :Henrollyear, Hspeciality,:Hdno;</span><br><span class="line">&#125;</span><br><span class="line">EXEC SQL CLOSE Student_Cursor;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Acwing周赛102</title>
      <link href="/2023/05/08/Acwing%E5%91%A8%E8%B5%9B102/"/>
      <url>/2023/05/08/Acwing%E5%91%A8%E8%B5%9B102/</url>
      
        <content type="html"><![CDATA[<h1 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a><a href="https://www.acwing.com/problem/content/4979/">倍增</a></h1><p>这是一道简单数论题</p><figure class="highlight plaintext"><figcaption><span><bits/stdc++.h></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line"></span><br><span class="line">int a[N], n;</span><br><span class="line"></span><br><span class="line">int div(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x % 2 == 0)</span><br><span class="line">        while(x % 2 == 0)    x /= 2;</span><br><span class="line">    if(x % 3 == 0)</span><br><span class="line">        while(x % 3 == 0)    x /= 3;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 1; i &lt;= n; ++ i)    scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    for(int i = 1; i &lt;= n; ++ i)    a[i] = div(a[i]);</span><br><span class="line">    for(int i = 1; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[1] != a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三元组"><a href="#三元组" class="headerlink" title=" 三元组"></a><a href="https://www.acwing.com/problem/content/4980/"> 三元组</a></h1><p>这道题目我们可以直接用stlmap套vector+stl的二分暴力来做也可以选择用前后缀分解，前后缀分解是我第一次见这种思想，会用一篇博客单独整理运用这种思想的题目</p><blockquote><p>stl直接做</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">LL ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    map&lt;LL, vector&lt;<span class="type">int</span>&gt;&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        mp[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ay = a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i] % k == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LL ax = ay / k, az = <span class="number">1LL</span> * ay * k;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(ax) != mp.<span class="built_in">end</span>() &amp;&amp; mp.<span class="built_in">find</span>(az) != mp.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; v1 = mp[ax];</span><br><span class="line">                <span class="keyword">auto</span>&amp; v2 = mp[az];</span><br><span class="line">                <span class="type">int</span> m = v2.<span class="built_in">size</span>();</span><br><span class="line">                <span class="type">int</span> k1 = <span class="built_in">lower_bound</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), i) - v1.<span class="built_in">begin</span>();</span><br><span class="line">                <span class="keyword">if</span>(k1 &gt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    -- k1;</span><br><span class="line">                    <span class="type">int</span> k2 = <span class="built_in">upper_bound</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), i) - v2.<span class="built_in">begin</span>();</span><br><span class="line">                    ans += <span class="number">1LL</span> * (k1 + <span class="number">1</span>) * (m - k2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>前后缀分解去做</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">LL a[N];</span><br><span class="line">map&lt;LL, LL&gt;l, r;</span><br><span class="line">LL ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">        r[a[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        r[a[i]] --;</span><br><span class="line">        <span class="keyword">if</span>(a[i] % k == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l.<span class="built_in">find</span>(a[i] / k) != l.<span class="built_in">end</span>() &amp;&amp; r.<span class="built_in">find</span>(a[i] * k) != r.<span class="built_in">end</span>()) </span><br><span class="line">                ans += <span class="number">1LL</span> * l[a[i] / k] * r[a[i] * k];</span><br><span class="line">        &#125;</span><br><span class="line">        l[a[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Acwing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 前后缀分解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ccpc省赛游记</title>
      <link href="/2023/05/08/CCPC%E7%9C%81%E8%B5%9B%E6%B8%B8%E8%AE%B0/"/>
      <url>/2023/05/08/CCPC%E7%9C%81%E8%B5%9B%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="考完试再补"><a href="#考完试再补" class="headerlink" title="考完试再补"></a>考完试再补</h1>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型</title>
      <link href="/2023/05/08/Java%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/05/08/Java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型使用"><a href="#泛型使用" class="headerlink" title="泛型使用"></a>泛型使用</h1><p>泛型的本质是参数化类型<br>1、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt;&#123;&#125; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><p>T和E必须是引用类型不能是基本类型<br>2、使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//后面可以直接缺省java编译器会帮我们自动推断</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>3、如果不写默认为Object类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure><h1 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h1><h2 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h2><p>语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class&lt;T, E,&gt; 类名&#123;&#125;</span><br></pre></td></tr></table></figure><p>1、普通成员均可以使用泛型<br>2、静态成员不能使用泛型<br>3、泛型数组不能初始化<br>4、泛型的类型是在创建对象时确定的</p><h2 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h2><p>语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名 &lt;T, E,&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>1、接口中的静态成员也不能使用泛型<br>2、接口中的泛型在继承接口或实现接口时确定类型<br>3、没有指定类型，默认Object</p><h2 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h2><p>语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T, E,&gt; 返回类型 方法名（参数列表） &#123;&#125;</span><br></pre></td></tr></table></figure><p>1、泛型方法可以定义在普通类】也可以定义在泛型类<br>2、泛型方法在被调用时确定其类型<br>3、注意区别，方法使用泛型和泛型方法</p><h1 id="泛型的继承和通配"><a href="#泛型的继承和通配" class="headerlink" title="泛型的继承和通配"></a>泛型的继承和通配</h1><p>1、泛型不具备继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;:可以接收任何类型</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Employee</span>&gt;:可以接收Employee的子类（包括非直接子类）</span><br><span class="line">List&lt;? <span class="built_in">super</span> Employee&gt;:可以接收Employee的父类（包括非直接父类）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 848 (Div. 2)B</title>
      <link href="/2023/05/06/848-div2-B/"/>
      <url>/2023/05/06/848-div2-B/</url>
      
        <content type="html"><![CDATA[<h1 id="B-The-Forbidden-Permutation"><a href="#B-The-Forbidden-Permutation" class="headerlink" title="B. The Forbidden Permutation"></a><a href="https://codeforces.com/contest/1778/problem/B">B. The Forbidden Permutation</a></h1><blockquote><p>一定要注意题目中说的是对于all i满足才算不好的，我们做的时候只要破坏一个i这个a就不算好的了,被这一点坑了，没注意到all。</p></blockquote><p>我们只需要从前往后做一遍，对于满足题中不等式的a[i]我们的操作是把a[i + 1]移到a[i]前面，一种操作是，将a[i + 1]向后移直到破坏后面的条件，（注意不能移出边界）<br>最后两种操作取最小值即可，如果我们未操作时题目中就有不满足的a[i]，此时答案就为0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N], a[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line"><span class="type">int</span> n, m, d;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;d);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">p[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[a[i + <span class="number">1</span>]] &lt; p[a[i]] || p[a[i + <span class="number">1</span>]] &gt; p[a[i]] + d)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p[a[i + <span class="number">1</span>]] &gt; p[a[i]])ans = <span class="built_in">min</span>(ans, p[a[i + <span class="number">1</span>]] - p[a[i]]);</span><br><span class="line"><span class="keyword">if</span>(p[a[i + <span class="number">1</span>]] &lt;= p[a[i]] + d)</span><br><span class="line"><span class="keyword">if</span>(d + <span class="number">2</span> &lt;= n)ans = <span class="built_in">min</span>(ans, p[a[i]] + d + <span class="number">1</span> - p[a[i + <span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 856 (Div. 2)C</title>
      <link href="/2023/05/06/856-div2-C/"/>
      <url>/2023/05/06/856-div2-C/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Scoring-Subsequences"><a href="#C-Scoring-Subsequences" class="headerlink" title="C. Scoring Subsequences"></a><a href="https://codeforces.com/problemset/problem/1794/C">C. Scoring Subsequences</a></h1><p>思路：我们想要找到满足的最大值的长度最长的的区间，因为单调不减，所以更大的数一定在最大值的里面包含，所以我们用两个指针维护这样一个满足当前i的最大值区间，当新来一个数，这时我们答案里面一定要包含这个数，我们看能否保持这个长度，能不能保持需要看j指针所指的数/区间长度和1的大小比较，如果大于1乘上去一定可以使结果增大，反之会使结果减小，那么这个数就不能要了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N]; </span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(j &lt;= i &amp;&amp; a[j] / (i - j + <span class="number">1</span>) &lt; <span class="number">1</span>)++ j;</span><br><span class="line">cout &lt;&lt; i - j + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeTON Round 4 (Div. 1 + Div. 2)C</title>
      <link href="/2023/05/06/CodeTON-Round-4-Div-1-Div-2-C/"/>
      <url>/2023/05/06/CodeTON-Round-4-Div-1-Div-2-C/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Make-It-Permutation"><a href="#C-Make-It-Permutation" class="headerlink" title="C. Make It Permutation"></a><a href="https://codeforces.com/contest/1810/problem/C">C. Make It Permutation</a></h1><p>我们希望尽可能少地进行操作可以使代价最小，我们如果要排列的话，那些重复的元素我们无论如何都要进行删除的，所以我们可以先把去重的代价计算出来，然后依次枚举排列的位数是多少，也就是枚举去重后的数组，其中的代价我们可以一次计算出来，当我们枚举第i个a时，前面1有 i - 1个数，而1~ai - 1所有数都需要有，所以一共需要补ai - i个数，而i后面所有数都需要删除需要删m - i个数，代价我们可以通过O（1）的时间复杂度计算出来，然后枚举i更新答案即可。</p><p>时间复杂度：O（n）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> c[N]; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line">LL val = <span class="number">0</span>, ans = <span class="number">2e18</span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">find</span>(x) == s.<span class="built_in">end</span>())s.<span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">else</span> val += a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it : s)c[++ m] = it;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL k = <span class="number">1LL</span> * (c[i] - i) * b + <span class="number">1LL</span> * (m - i) * a;</span><br><span class="line">ans = <span class="built_in">min</span>(k, ans);</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">min</span>(ans, <span class="number">1LL</span> * m * a + b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, val + ans);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 865 (Div. 1)A</title>
      <link href="/2023/05/05/865-div1-A/"/>
      <url>/2023/05/05/865-div1-A/</url>
      
        <content type="html"><![CDATA[<h1 id="A-Ian-and-Array-Sorting"><a href="#A-Ian-and-Array-Sorting" class="headerlink" title="A. Ian and Array Sorting"></a><a href="https://codeforces.com/problemset/problem/1815/A">A. Ian and Array Sorting</a></h1><p>思路：首先我们可以从前往后做一遍，把除了最后一个元素其他所有数都变成和第一个数一样的数，然后假如前n-1个数个数为偶数，这样我们分组进行操作，一定可以把所有数变成无限小，也就是说一定会有解，也就是说n为奇数一定有解，我们考虑n为偶数的情况，n为偶数，我们从前往后做一遍，前n-1个数相同，前n-2个数一定可以变为无穷小，所以我们只需要比较最后两个数也就是n-1和n的大小即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;LL&gt;a, b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line">b.<span class="built_in">clear</span>();</span><br><span class="line"><span class="type">int</span> n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL x;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">a.<span class="built_in">push_back</span>(x);</span><br><span class="line">b.<span class="built_in">push_back</span>(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">bool</span> success = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">if</span>(a[i] != b[i])success = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(success)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>)<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL d = a[i - <span class="number">1</span>] - a[i];</span><br><span class="line">a[i] += d;</span><br><span class="line">a[i + <span class="number">1</span>] += d;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(a[n - <span class="number">2</span>] &lt;= a[n - <span class="number">1</span>])<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">else</span><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 866 (Div. 1)A</title>
      <link href="/2023/05/05/866-div1-A/"/>
      <url>/2023/05/05/866-div1-A/</url>
      
        <content type="html"><![CDATA[<h1 id="A-Constructive-Problem"><a href="#A-Constructive-Problem" class="headerlink" title="A. Constructive Problem"></a><a href="https://codeforces.com/problemset/problem/1819/A">A. Constructive Problem</a></h1><p>题意：给定一个长度为n的非负数组a，我们可以进行一次操作，操作是将l~r这个区间内的所有数变为k（k &gt;= 0），得到b，能不能使mex（a）+ 1 = mex（b）</p><p>思路：我是先排了个序，去了一下重，然后得到的这个数组其实只有两种情况<br><img src="https://s2.loli.net/2023/05/05/JIwPBDQqVZ5FliK.jpg" alt="7fadb345668574e200b410c44f14b05.jpg"><br><img src="https://s2.loli.net/2023/05/05/17OtNERXlZaFKV3.jpg" alt="cdc76ad46ad0e20e462b088d676162b.jpg"><br>一种每两个数之间的增量为1<br>一种是每两个数之间的增量大于1<br>对于第一种情况<br>我们考虑原数组大小如果和去重后数组大小相同，这种情况是不能增大的<br>否则说明有重复元素，我们只需要将重复元素变为n+1即可也就是说一定有解<br>对于第二种情况<br>我们考虑第一个增量不为一的地方<br>假如这个地方的增量为2这样我们就需要将这包含这个数的最小区间内的所有数变成mex（a）+1<br>然后扫一遍check以下就做完了<br>假如第一个增量不为一的地方的增量&gt;=3则一定有解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b.<span class="built_in">clear</span>();</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), b.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; a[<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">b.<span class="built_in">erase</span>(<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(b[<span class="number">0</span>] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b.<span class="built_in">size</span>() - <span class="number">1</span> == b[b.<span class="built_in">size</span>() - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n == b.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i] != i)<span class="keyword">break</span>;</span><br><span class="line">t = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b[t + <span class="number">1</span>] - b[t] &gt;= <span class="number">3</span>)<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] == b[t + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">l = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] == b[t + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">r = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt;= l &amp;&amp; i &lt;= r)<span class="keyword">continue</span>;</span><br><span class="line">mp[a[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= b[t]; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(mp.<span class="built_in">find</span>(i) == mp.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高速存储器</title>
      <link href="/2023/05/05/%E9%AB%98%E9%80%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/05/05/%E9%AB%98%E9%80%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="双端口存储器"><a href="#双端口存储器" class="headerlink" title="双端口存储器"></a>双端口存储器</h1><h2 id="双端口处理器的逻辑结构"><a href="#双端口处理器的逻辑结构" class="headerlink" title="双端口处理器的逻辑结构"></a>双端口处理器的逻辑结构</h2><p>1、一个存储器具有两组相互独立的读写控制电路。<br>2、两个端口具有独立的数据线、读写线、控制线。<br>3、两个端口可对存储器中任何位置上的数据进行独立的存取操作</p><p><img src="https://s2.loli.net/2023/05/04/wY41XTghCbZ3f7k.png" alt="双端口处理器逻辑图.png"></p><h2 id="双端口处理器的读写"><a href="#双端口处理器的读写" class="headerlink" title="双端口处理器的读写"></a>双端口处理器的读写</h2><h3 id="无冲突读写"><a href="#无冲突读写" class="headerlink" title="无冲突读写"></a>无冲突读写</h3><p>当两个端口的地址不同时，在两个端口上进行读写操作一定不会发生冲突</p><h3 id="有冲突读写"><a href="#有冲突读写" class="headerlink" title="有冲突读写"></a>有冲突读写</h3><p>两个端口同时读写一个地址时便可能发生冲突，这是我们通过设置一个BUSY标志来解决冲突</p><h1 id="多模块交叉存储器"><a href="#多模块交叉存储器" class="headerlink" title="多模块交叉存储器"></a>多模块交叉存储器</h1><h2 id="存储器的模块化组织"><a href="#存储器的模块化组织" class="headerlink" title="存储器的模块化组织"></a>存储器的模块化组织</h2><p>多体并行存储器也能解决cpu速度与存储器速度不匹配的问题</p><blockquote><p>这里存取我们都考虑的是存取连续空间里的数据，因为我们通常的数据、代码、指令还有数组等这些东西，都是在连续的地址空间里进行存储的，也就是说大部分情况我们访存都是访问的连续地址</p></blockquote><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>假如我们现在要访问一段连续地址（00000~00100），我们访问00000后需要等待T（存储器的存取周期）后才能进行下一次访问00001<br><img src="https://s2.loli.net/2023/05/04/vbKj1spVgtZ8ldN.png" alt="顺序方式.png"><br>所以我们需要的总时间就如下：<br>5T<br><img src="https://s2.loli.net/2023/05/04/DmlbYJIwp83ykKs.png" alt="高位交叉编址.png"></p><h3 id="交叉存储"><a href="#交叉存储" class="headerlink" title="交叉存储"></a>交叉存储</h3><p>而交叉存储时，我们访问一段连续地址，当我们访问00000之后，00000所在存储体进入恢复阶段，我们可以接着访问00001，因为他们不在一个存储体中，而访问玩00001后，我们可以直接访问00010，这样前两个存储题都进行了恢复，所以通过这种交叉存储可以实现流水线式的并行工作</p><p><img src="https://s2.loli.net/2023/05/04/MNU8kVIZj43zerb.png" alt="交叉存储.png"><br>所以低位交叉存储的时间如下：<br>这里我们假设T=4r，T为存取周期，r为cpu取数的时间，也就是说，当我们访问完最后一个存储体后，第一个存储体就又恢复好了，我们就可以接着对第一个存储体进行访问了,<br>读取n个字所需的时间为<br>t = T + (n - 1)r<br><img src="https://s2.loli.net/2023/05/04/kZ65tVuBNy3fYKr.png" alt="低位交叉存储.png"></p><h4 id="低位交叉存储中我们需要设计多少个存储体合适呢？"><a href="#低位交叉存储中我们需要设计多少个存储体合适呢？" class="headerlink" title="低位交叉存储中我们需要设计多少个存储体合适呢？"></a>低位交叉存储中我们需要设计多少个存储体合适呢？</h4><p>我们应该保证存储体个数m &gt;= T / r，这是什么原因呢？<br>我们可以这样考虑，当T / r表示一个存储体从访问开始到下次再能访问需要有几个存储体可以<br>当存储体个数比较少时，cpu访问完所有存储体后，第二次访问第一次访问的存储体，这时这个存储体还没有恢复好，cpu需要等待其恢复好，才能进行访问，而当m个数比较多时，cpu还没有再次访问到第一次访问的存储体，他就已经回复好了，这是存储体就需要等待cpu<br>所以最好的状态是cpu刚好访问一遍存储体，最初访问的存储体刚刚恢复好，这样既没有产能过剩也没有有人偷懒的情况<br><img src="https://s2.loli.net/2023/05/04/fxIncuETp7s6Oaq.png" alt="未充分利用.png"><br><img src="https://s2.loli.net/2023/05/04/V5ND7cSLOHQWh6i.png" alt="产能过剩.png"><br><img src="https://s2.loli.net/2023/05/04/BYAfzMdJF1D8co5.png" alt="比较完美.png"></p><h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><h2 id="Cache概述"><a href="#Cache概述" class="headerlink" title="Cache概述"></a>Cache概述</h2><h3 id="Cache的功能"><a href="#Cache的功能" class="headerlink" title="Cache的功能"></a>Cache的功能</h3><p>1、Cache是为了解决CPU与主存之间速度不匹配的一项技术<br>2、介于CPU和主存之间的一种小容量的高速缓冲器<br>3、基于局部性原理<br>4、全部功能由硬件实现，对程序员透明</p><h3 id="Cache的基本原理"><a href="#Cache的基本原理" class="headerlink" title="Cache的基本原理"></a>Cache的基本原理</h3><p>CPU与Cache之间的数据交换是以字为单位的，而Cache和主存之间的数据交换是以块为单位的。一个块是由若干字组成的。当CPU需要读取内存中的一个字时，就会发出这个字的内存地址到Cache和主存。此时Cache控制逻辑依据地址判断此字目前是否在Caxhe中。若在，则此字立刻传送给CPU若不在，则用主存读周期读出送入CPU，并且不含有这个字的块送入Cache。<br><img src="https://s2.loli.net/2023/05/04/Qm8kKDgUG2qV3pr.png" alt="Cache原理图.png"></p><h3 id="Cache命中率"><a href="#Cache命中率" class="headerlink" title="Cache命中率"></a>Cache命中率</h3><p>h表示Cache命中率，Nc表示Cache存取次数，Nm表示主存完成的存取次数，<br>h = Nc / （Nc + Nm）</p><h3 id="Cache平均访问时间"><a href="#Cache平均访问时间" class="headerlink" title="Cache平均访问时间"></a>Cache平均访问时间</h3><p>tm未命时主存的访问时间，tc命中时Cache的访问时间<br>t = （1 - h）tm + h*tc</p><h3 id="Cache的总容量"><a href="#Cache的总容量" class="headerlink" title="Cache的总容量"></a>Cache的总容量</h3><p>存储容量和标记阵列容量（有效位、标志位、一致性维护位、替换算法控制位）</p><blockquote><p>标记阵列中有效位和标志位一定存在，一致性维护位涉及写回操作，替换算法控制位取决于Cache使用了什么替换算法<br>eg：</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/92bxWvRaBXtjMeN.jpg" alt="4b7ed8f05e9e610b15628266b5ff384.jpg"></p><p>Cache的存储容量是4K个字，每个字占32位所以总容量是128K位</p><p><img src="https://s2.loli.net/2023/05/10/WoutKh9H4iOXT2j.jpg" alt="a2cc81652ee0789d1e6bc731e717433.jpg"></p><p>我们知道主存块的大小是4个字，每个字是32位，按字节编址，字块内地址有32 * 4 / 8 = 16 = 2 ^ 4，所以字块内地址有4位<br>Cache块大小和主存相同，所以Cache块的个数有4K/4 = 1K个<br>所以Cache字块占10位<br>所以贮存快标记位占18位<br>每个Cache对应一个标记项如下图：</p><p><img src="https://s2.loli.net/2023/05/10/AlmR1fqLodetVZD.jpg" alt="a48091b80032fb74f5877c9400e8842.jpg"></p><p>而有效位、标志位是必须的、题中说了直接写回，所以一致位也有，但未提及替换算法，所以不用管替换位所以标志项的位数至少是20位，有1K个Cache块，所以容量为20K<br>总容量就是128K+20K = 148K</p><h3 id="Cache的访问效率"><a href="#Cache的访问效率" class="headerlink" title="Cache的访问效率"></a>Cache的访问效率</h3><p><img src="https://s2.loli.net/2023/05/04/jdVt9GfEuYnBmhN.png" alt="Cache的访问效率.png"></p><h2 id="主存与Cache的映射"><a href="#主存与Cache的映射" class="headerlink" title="主存与Cache的映射"></a>主存与Cache的映射</h2><p>主存与Cache的映射方式共有三种：全相联映射、直接映射、组相联映射，下面依次介绍这三种</p><h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><p>主存中的任意块可以放在Cache中的任意行中<br>假设计算机的主存地址空间为256MB，按字节编址，其中Cache有8行，行长为64B<br><img src="https://s2.loli.net/2023/05/05/G4T2YRSVw3vkr5p.png" alt="全相联映射.png"><br>Cache与主存之间的信息交换是以块为单位的<br><img src="https://s2.loli.net/2023/05/05/W4njLUZy6xg2qbM.png" alt="全相联影射2.png"><br>所以我们需要有效位来指明Cache中的数据是否有效，然后需要标记为指明当前Cache中存储的信息是主存中哪个地址的信息。<br>CPU如何访存呢？首先，拿出要访问主存的地址的前22位和Cache中的所有块一一对比，并检查是否命中，若命中则根据低6位在每块中查找，若未命中则在主存中进行访存<br><img src="https://s2.loli.net/2023/05/05/uj9b4kdHDQzc1w6.png" alt="全相联映射5.png"></p><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>每个主存块只能放在Cache的固定位置<br>没有全相联映射灵活，而且Cache中空间利用很不充分<br><img src="https://s2.loli.net/2023/05/05/WeY89RujhNc3UKA.png" alt="直接映射1.png"><br><img src="https://s2.loli.net/2023/05/05/oz2k5WY691n3d8T.png" alt="直接映射2.png"><br>我们可以优化主存块号这一项，因为主存快号末尾3位就直接指示了该地址在Cache中的存放位置，所以我们就没有必要再存储<br><img src="https://s2.loli.net/2023/05/05/KI6ivpUhdq1u2ax.png" alt="直接映射4.png"></p><h3 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h3><p>每一个主存块可以被放在特定Cache组的任意位置<br><img src="https://s2.loli.net/2023/05/05/XoCHSuMDEwVxkAh.png" alt="组相联映射.png"><br><img src="https://s2.loli.net/2023/05/05/KW3CYB4uH2MIoFS.png" alt="组相联映射2.png"><br><img src="https://s2.loli.net/2023/05/05/b69F58yEBhZnNVu.png" alt="组相联映射3.png"></p><h2 id="Cache的替换"><a href="#Cache的替换" class="headerlink" title="Cache的替换"></a>Cache的替换</h2><p>Cache的工作原理是使其保存新的数据，这样当Cache满了或则我们的旧数据占据了新数据的Cache位时这时就会需要替换策略<br>而直接映射是不需要替换策略的，因为直接映射，每个内存块能在Cache中存放的位置固定的</p><blockquote><p>常见的替换算法共三种1、最不经常使用（LFU）、2、近期最少使用（LRU）3、随机替换</p></blockquote><h3 id="最不经常使用LFU"><a href="#最不经常使用LFU" class="headerlink" title="最不经常使用LFU"></a>最不经常使用LFU</h3><blockquote><p>算法思想：我们为每一个Cache块分配一个计数器，用于记录当前Cache块被访问过几次，d当Cache满了之后，我们挑选出计数器最小的进行替换。这种替换算法看似很科学，但是却忽略了很重的时间局部性原理，因为我们是从全局考虑的，我们可以思考这种情况，曾经我们经常访问的数据，未来并不一定经常访问，当我们之前一直访问一个内存块，这时这个内存块的计数器会变的很大，但是我们后来不再使用这个内存块，但是由于这个内存块的计数器很大，几乎不会被替换出来，这就导致这个Cache块基本被浪费掉了</p></blockquote><h3 id="近期最少使用LRU"><a href="#近期最少使用LRU" class="headerlink" title="近期最少使用LRU"></a>近期最少使用LRU</h3><blockquote><p>算法思想：将一段时间内访问次数最少的行换出，我们为每一个Cache块分配一个计数器，用于记录当前块多久没有被访问过，每次需要替换时将计数器最大Cache块替换出来</p></blockquote><p>这种算法遵循了时间局部性原理，保护了刚拷贝到Cache中的新数据行，Cache的命中率比较高<br><img src="https://s2.loli.net/2023/05/05/EqTBbLaeDj4SHXz.png" alt="LRU.png"><br>我们也可以在Cache命中时，把当前计数器置为0，其余行加1</p><h3 id="随机替换"><a href="#随机替换" class="headerlink" title="随机替换"></a>随机替换</h3><blockquote><p>算法思想：顾名思义就是当Cache满了之后随机把Cache中的一个块替换出来</p></blockquote><h2 id="Cache的写操作"><a href="#Cache的写操作" class="headerlink" title="Cache的写操作"></a>Cache的写操作</h2><p>Cache中保存的是主存数据的副本，当CPU对Cache中的数据进行修改时，我们怎么保证Cache中的数据副本和主存中的数据母本的一致性呢？这就是Cache写操作需要解决的问题</p><h3 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h3><p>1、当CPU写入Cache命中时，只修改Cache中的内容而不立即写入主存，只有当这一行被替换时，才将Cache中的内容写回主存<br>2、未命中时，依然是先将主存中的内容调入Cache，然后再Cache中进行写操作，当这一行被替换时，才将Cache中的内容写回主存<br>3、这种方法可以有效减少访问主存的次数，但是存在数据不一致的风险，我们是现实时需要有一个脏位记录当前是否修改过</p><h3 id="全写法"><a href="#全写法" class="headerlink" title="全写法"></a>全写法</h3><p>1、当cache写命中时，将同时写入cache和主存，较好地维护了主存与Cache数据的一致性<br>2、当擦车未命中时，只能直接向主存中进行写入，同时又有一个问题就是是否要将修改过的主存块放入Cache？可以放也可以不放</p><h3 id="写一次法"><a href="#写一次法" class="headerlink" title="写一次法"></a>写一次法</h3><p>？这里并不是很理解写一次法是什么，为什么在第一次写命中时同时写入主存便于维护所有Cache一致性呢？<br><img src="https://s2.loli.net/2023/05/05/6wJ2zPpIHLrqDBc.png" alt="写一次法.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java接口</title>
      <link href="/2023/05/04/Java%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/05/04/Java%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是给出一些没有实现的方法定义，等到某个类要使用时，再具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface 类名</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">属性</span><br><span class="line">方法</span><br><span class="line">&#125;；</span><br><span class="line">class 类名 implements 接口名</span><br><span class="line">&#123;</span><br><span class="line">属性</span><br><span class="line">方法</span><br><span class="line"><span class="comment">//接口的所有抽象方法都要实现</span></span><br><span class="line">接口方法的实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中的抽象方法可以不用abstact修饰，jdk7之前接口中的所有方法都是抽象方法，而jdk8之后接口中的方法可以默认实现方法，但要用default修饰，也可以有静态方法</p><h1 id="接口存在的意义"><a href="#接口存在的意义" class="headerlink" title="接口存在的意义"></a>接口存在的意义</h1><p>在我接口时一直有一个问题，直接在用到方法的类里直接实现方法不香吗？为什么还要定义接口呢？<br>可能对于现在阶段未工作的我们答案是这样的。<br>接口的便于维护和管理<br>比如我们有三个程序员要分别实现数据库Mysql，Orcel，DB2，我们都知道数据库有连接还有关闭功能，所以我们可以定义一个接口，让三个数据库都去实现这个接口，假如我们并不定义接口，a程序员可能实现这两个方法叫A，B，b程序员实现这两个方法又叫C， D这个每个程序员实现同样一种功能的方法，名字却各不相同，我们调用起来就很难搞，而这时候接口的作用就可体现出来了。<br>接口的作用还有很多，只是初学，我们先知道这玩意时是有用的就可以了。</p><h1 id="接口的使用细节"><a href="#接口的使用细节" class="headerlink" title="接口的使用细节"></a>接口的使用细节</h1><p>1、接口不能被实例化</p><blockquote><p>因为我们知道接口本身就是一个抽象的东西，关于为什么接口不能被实例化我搜索了一下资料，我们知道java的内存分为栈区、堆区、代码、静态数据这四部分。清楚了这个之后我们先看类的实例化是一个怎样的过程，如下图，首先我们先在栈区声明了一个per，然后JVM对per进行实例化，在堆区为其开辟一段空间，用来存储这个Person对象，那么堆内存里面具体存的是那些东西呢，其实堆内存里存储的是对象的属性，我们清楚这些之后就可以对接口进行分析了，接口中的属性是用static final修饰的，而我们看下图，可以知道java中static变量是存在方法区的，不在堆区，所以就没有必要在堆区为其分配内存，而方法也是不在堆区的，所以接口没有被实例化的必要，java就规定其不能被实例化</p></blockquote><p><img src="https://s2.loli.net/2023/05/04/5xVXFUunflQHJcB.jpg" alt="20150109212141406.jpg"><br><img src="https://s2.loli.net/2023/05/04/mApveOuf6bE1R2I.png" alt="java的内存分配（运行时）.png"><br>2、接口中的方法是public的，默认用public abstract修饰我们可以将其省略<br>3、一个普通类实现接口就必须将该类中的所有方法都实现（Idea中可以使用alt + /快速完成）<br>4、抽象类实现接口可以不用实现接口中的方法<br>5、一个类可以实现多个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">I1</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I2</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">I1</span>, I2</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//两个接口的方法都要实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、接口中的所有属性都是public static final<br>7、接口不能继承其他类，但是可以继承多个接口（这里的继承是和类的继承不相同的，类的继承是单一的，只能继承一个类，这里接口却可以继承多个接口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//偷懒这里就用上面的接口了</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I3</span> <span class="keyword">extends</span> <span class="title class_">I1</span>, I2</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>8、接口的修饰符只能是public和默认的（这点和类的修饰是一样的）</p><h1 id="接口和继承对比"><a href="#接口和继承对比" class="headerlink" title="接口和继承对比"></a>接口和继承对比</h1><blockquote><p>接口学到这里我们对接口就有了一个大概轮廓的认识，接口是对抽象类的延伸，接口是对行为的抽象，java为了保护数据安全是不允许多继承的，而接口则弥补了这一种缺陷，是对单继承机制的补充。</p></blockquote><p>继承是is_a的关系，而接口时like_a的关系</p><h1 id="接口的多态"><a href="#接口的多态" class="headerlink" title="接口的多态"></a>接口的多态</h1><p>1、接口可以接收实现了接口的类，接口变量可以接收实现了该接口的对象实例<br>2、多态传递</p><blockquote><p>如果一个接口IA继承了接口IB，一个类A实现了IA，那么我们可以用IB接口类型的变量来接收类A的实例，这就相当于A也实现了接口B，所以B类型的接口也可以接收A类的实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">IH</span> <span class="variable">Ih</span> <span class="operator">=</span> a;</span><br><span class="line">        <span class="type">IG</span> <span class="variable">Ig</span> <span class="operator">=</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IH</span>&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IG</span> <span class="keyword">extends</span> <span class="title class_">IH</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">IG</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储系统及主存储器</title>
      <link href="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="存储器的分类如下："><a href="#存储器的分类如下：" class="headerlink" title="存储器的分类如下："></a>存储器的分类如下：</h3><p><img src="https://s2.loli.net/2023/05/03/xLuh7DlKtoQYwB5.png" alt="分类.png"></p><h3 id="主存的分类："><a href="#主存的分类：" class="headerlink" title="主存的分类："></a>主存的分类：</h3><p>主存分为随机存储器（RAM）和静态存储器（RAM），随机存储器又分为静态RAM和动态RAM<br><img src="https://s2.loli.net/2023/05/03/xHE7XDCUaOSivkQ.png" alt="存储器的分类.png"></p><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="金字塔结构"><a href="#金字塔结构" class="headerlink" title="金字塔结构"></a>金字塔结构</h3><p><img src="https://s2.loli.net/2023/05/03/CAuS7M5EiXg4yo6.png" alt="金字塔.png"></p><h3 id="主存-辅存及主存-缓存结构"><a href="#主存-辅存及主存-缓存结构" class="headerlink" title="主存-辅存及主存-缓存结构"></a>主存-辅存及主存-缓存结构</h3><p>主存-辅存结构主要解决的问题是主存容量的问题，因为主存的容量小。<br>主存-缓存结构主要解决的是cpu速度与主存访问速度不同的问题，cpu处理速度快，而从主存中读写数据慢，我们添加一个高速缓存事先存在缓存中，这样可以提高速度<br><img src="https://s2.loli.net/2023/05/03/kAQgxL5j2tvNJ93.png" alt="存储层次.png"></p><h2 id="存储器的技术指标"><a href="#存储器的技术指标" class="headerlink" title="存储器的技术指标"></a>存储器的技术指标</h2><p>存储容量：在一个存储器中可以容纳存储单元的个数 单位字或字节数<br>存取时间：从接收到读写指令开始到完成一次存取操作的时间 ns<br>存取周期：连续两次访问存储器的最小时间间隔 ns<br>存储器带宽：单位时间里存储器所取信息量 位/s， 字节/秒<br>存取周期略大于存取时间</p><h1 id="静态存储器SRAM"><a href="#静态存储器SRAM" class="headerlink" title="静态存储器SRAM"></a>静态存储器SRAM</h1><p>1、地址译码器：控制选择存储矩阵中的哪一个存储单元。地址线有M根，就有2^M个存储单元<br>2、存储矩阵：内包含若干存储单元<br>3、控制电路：控制电路是否工作、以及工作状态下是进行读操作还是进行写操作<br>4、存储容量=存储单元个数*存储字长（可能有人要问存储字长是什么？和机器字长的关系是什么呢？）</p><blockquote><p>先说一下字长的概念：<br>（1）、存储字长：一个存储单元中二进制代码的位数<br>（2）、机器字长：cpu进行一次整数运算所能处理的二进制位数（和ALU的输入端位数直接相关，而ALU的数据来源又是寄存器和内部数据总线）<br>通常机器字长是存储字长的整数倍<br>（3）、指令字长：一条指令的总长度（可能会发生改变）</p></blockquote><p><img src="https://s2.loli.net/2023/05/03/OHmLRBKCseoYXq6.png" alt="存储器的基本结构.png"></p><h2 id="下面是基本的静态存储元阵列："><a href="#下面是基本的静态存储元阵列：" class="headerlink" title="下面是基本的静态存储元阵列："></a>下面是基本的静态存储元阵列：</h2><p>1个存储元用来存储一个二进制位的信息，对应为下图中的一个小方块<br><img src="https://s2.loli.net/2023/05/03/kfHaQjTBibtNhM1.png" alt="基本的静态存储元阵列.png"></p><h2 id="SRAM的记忆原理"><a href="#SRAM的记忆原理" class="headerlink" title="SRAM的记忆原理"></a>SRAM的记忆原理</h2><p>SRAM是用一个锁存器（触发器）来作为存储单元的<br>我们可以看下图给选择线一个低电平使其工作，假设这时我们想要写入数据，我们给数据入一个低电平，这时通过第一个与非门的信号为低电平，通过1号或门的信号为高电平而通过二号或门的电信号为高电平，也会使通过1号或门的电信号为高电平，阻止数据出这样相互耦合的电路使信息保存稳定，只要不断电就能无限期保存</p><p><img src="https://s2.loli.net/2023/05/03/l5WUc3zfijKCbu7.png" alt="静态RAM的记忆原理.png"></p><h2 id="两种译码方式的RAM"><a href="#两种译码方式的RAM" class="headerlink" title="两种译码方式的RAM"></a>两种译码方式的RAM</h2><h3 id="单译码方式的RAM"><a href="#单译码方式的RAM" class="headerlink" title="单译码方式的RAM"></a>单译码方式的RAM</h3><p>1、特点：只用一个译码器选中存储单元中的各位<br>2、优点：结构简单，存取速度快，适用于小容量<br>3、缺点：外围电路多、成本昂贵<br><img src="https://s2.loli.net/2023/05/03/PwYqxm7lK83dtL2.png" alt="单译码方式的RAM.png"></p><h3 id="双译码方式的RAM"><a href="#双译码方式的RAM" class="headerlink" title="双译码方式的RAM"></a>双译码方式的RAM</h3><p>目前的SRAM多采用双译码方式，为了组织更大的存储量。<br>所谓双译码，就是采用而二级译码将地址分为两部分（我们用x向和y向表示），我们先对x、y分别译码，然后再在存储阵列中进行二次译码。</p><blockquote><p>其实就是第一次译码确实x，y然后根据坐标再确定具体的位置<br><img src="https://s2.loli.net/2023/05/03/IWCElgavd4k13cx.png" alt="双译码方式的RAM.png"></p></blockquote><h3 id="两种译码方式的比较"><a href="#两种译码方式的比较" class="headerlink" title="两种译码方式的比较"></a>两种译码方式的比较</h3><p>这里我们通过一个具体的例子来看<br><img src="https://s2.loli.net/2023/05/03/QqxnEfSIzaNe65A.png" alt="单译码双译码的比较.png"></p><h3 id="SRANM的读写周期"><a href="#SRANM的读写周期" class="headerlink" title="SRANM的读写周期"></a>SRANM的读写周期</h3><h4 id="读周期"><a href="#读周期" class="headerlink" title="读周期"></a>读周期</h4><p>1、地址线先有效<br>2、待地址线选中存储单元后片选线和读出信号开始工作<br>3、等到片选线和读出信号都恢复高电平后地址线才恢复<br><img src="https://s2.loli.net/2023/05/03/wIXvjO1gkPp9ixl.png" alt="屏幕截图 2023-05-03 172344.png"></p><h3 id="写周期"><a href="#写周期" class="headerlink" title="写周期"></a>写周期</h3><p>1、地址线先有效<br>2、然后片选线有效，<br>3、写命令有效<br>4、撤销写命令<br>5、片选线维持的时间也比读周期长<br><img src="https://s2.loli.net/2023/05/03/CH4uITSwV3hqJME.png" alt="屏幕截图 2023-05-03 172352.png"></p><h1 id="动态存储器DRAM"><a href="#动态存储器DRAM" class="headerlink" title="动态存储器DRAM"></a>动态存储器DRAM</h1><p>DRAM存储器的存储元有一个MOS晶体管和电容器组成，MOS晶体管的作用是作为开关，存储信息是通过电容器上的电荷量体现的</p><h2 id="DRAM的读写过程"><a href="#DRAM的读写过程" class="headerlink" title="DRAM的读写过程"></a>DRAM的读写过程</h2><h3 id="写0和写1"><a href="#写0和写1" class="headerlink" title="写0和写1"></a>写0和写1</h3><p>写1：输出缓冲器、刷新缓冲器关闭、输入缓冲器打开，输入数据Din = 1送到存储元位线上，行线为高，MOS管被打开，这样电容就充电，表示存储了1<br>写0：输出缓冲器、刷新缓冲器关闭、输入缓冲器打开，输入数据Din = 0送到存储元位线上，行线为低，MOS管被打开，这样电容就放电，表示存储了0<br><img src="https://s2.loli.net/2023/05/03/6PkEAF3CdiTUrsl.png"></p><h3 id="读出过程"><a href="#读出过程" class="headerlink" title="读出过程"></a>读出过程</h3><p>读1：输入缓冲器、刷新缓冲器关闭、输出缓冲器打开，行线为高，MOS管打开，电容上存储的1被送进Dout<br>刷新：输入缓冲器关闭、刷新缓冲器打开、输出缓冲器打开，行线为高，MOS管打开，读出数据Dout经过刷新缓冲器被送到位线上，经MOS管写入电容上。<br><img src="https://s2.loli.net/2023/05/03/RPJUW9FE7ZGM8DH.png" alt="DRAM刷新.png"></p><h2 id="DRAM的逻辑结构"><a href="#DRAM的逻辑结构" class="headerlink" title="DRAM的逻辑结构"></a>DRAM的逻辑结构</h2><p>1、两个电源线Vcc、两个地线，还有一个空脚线NC<br>2、地址线只有10根而我们是1M的存储器，这里是不是很奇怪？因为这里我们用的是分时传送见下<br><img src="https://s2.loli.net/2023/05/03/N1HTgxsKnLFbEa4.png" alt="管脚图.png"><br>1、与SRAM不同我们增加了行地址锁存器和列地址锁存器，因为我们DRAM存储器的容量很大，地址线的宽度要相应增加，这会导致芯片引脚数增加，所以为了避免引脚数太多，这里我们选择的是分时传送，地址线的总宽度是10位，先送A0<del>A9，由RAS打入行锁存器，再送A10</del>A19，有CAS打入列锁存器<br>2、与SRAM不同我们增加了刷新计数器和控制电路。DRAM读出之后必须要刷新，未读写的存储元也要定期刷新，并且要按行刷新，刷新操作是与读写操作交替进行的，所以这里用了二选一数据选择器来提供刷新和读写操作</p><p><img src="https://s2.loli.net/2023/05/03/RvTQMn9WVlIxZjy.png" alt="DRAM结构图.png"></p><h2 id="DRAM的读写周期"><a href="#DRAM的读写周期" class="headerlink" title="DRAM的读写周期"></a>DRAM的读写周期</h2><p><img src="https://s2.loli.net/2023/05/03/MyjLOPufCcUzaHx.png" alt="DRAM读周期.png"><br><img src="https://s2.loli.net/2023/05/03/Tjwadnlz2LFOtiX.png" alt="DRAM写周期.png"></p><h2 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h2><p>1、刷新操作和读操作类似只是不向外输出<br>2、按行定期刷新<br>3、刷新方式有两种，集中式和分布式</p><h3 id="集中式刷新"><a href="#集中式刷新" class="headerlink" title="集中式刷新"></a>集中式刷新</h3><p>DRAM所有行在每一个刷新周期中都被集中刷新，对正常的读写周期不会产生影响<br>但是死时间时间过长<br><img src="https://s2.loli.net/2023/05/03/CgzRm6OaKkuN3YM.png" alt="集中式刷新.png"></p><h3 id="分散式刷新"><a href="#分散式刷新" class="headerlink" title="分散式刷新"></a>分散式刷新</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>将每一行的刷新分散到每个存取周期中<br>增长了存取周期<br>刷新过于频繁<br><img src="https://s2.loli.net/2023/05/03/s4aKltA17WJFywo.png" alt="分布式刷新1.png"></p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>两毫米内分散地把128行刷新一次，没有死时间<br><img src="https://s2.loli.net/2023/05/03/gd7W3BwRmoQvIhx.png" alt="分布式刷新2.png"></p><h2 id="DRAM和SRAM的比较"><a href="#DRAM和SRAM的比较" class="headerlink" title="DRAM和SRAM的比较"></a>DRAM和SRAM的比较</h2><h1 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h1><h2 id="ROM分类"><a href="#ROM分类" class="headerlink" title="ROM分类"></a>ROM分类</h2><p>ROM分为掩膜ROM、一次可编程ROM、光擦可编程ROM、电擦可编程ROM<br><img src="https://s2.loli.net/2023/05/03/3w9FsZeO8Q4UnPY.png" alt="ROM分类.png"></p><h2 id="MROM"><a href="#MROM" class="headerlink" title="MROM"></a>MROM</h2><p>1、存储内容固定的ROM、由掩膜工艺一次性制成<br>2、一旦制成无法改变<br>3、下图中绿色表示存储1，黄色代表存储0，在出厂时就已经确定<br><img src="https://s2.loli.net/2023/05/03/U7MWCy2pf6KL5qh.png" alt="MROM.png"></p><h2 id="PROM"><a href="#PROM" class="headerlink" title="PROM"></a>PROM</h2><p>PROM只能进行一次性的写入，出场时全为1或0，可根据自己的需要修改，但修改是不可逆的</p><h2 id="EPROM"><a href="#EPROM" class="headerlink" title="EPROM"></a>EPROM</h2><p><img src="https://s2.loli.net/2023/05/03/9yoTPQWRq1A7xNp.png" alt="EPROM.png"><br>1、可进行多次编程<br>2、悬空的没有引出线称为浮空栅，G为控制栅<br>3、存储信息是根据浮空栅上有没有电子来确定的，浮空栅上有电子，存储信息为0，浮空栅上没有电子存储信息为1</p><h2 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h2><p><img src="https://s2.loli.net/2023/05/03/wqgNSd9WzrVDb2h.png" alt="EEPROM.png"></p><h1 id="存储器容量扩展"><a href="#存储器容量扩展" class="headerlink" title="存储器容量扩展"></a>存储器容量扩展</h1><h2 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h2><p>只加长存储单元的字长，不增加存储单元的数量<br>数据线单独链接，地址线还有片选线、读写控制线连接在一起<br><img src="https://s2.loli.net/2023/05/03/Zk7dWBqlj8Se4ct.png" alt="位扩展.png"></p><h2 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h2><p>仅在字数方向扩展，位数不变</p><blockquote><p>eg4片16K<em>8位芯片扩展成64K</em>8位芯片</p></blockquote><p><img src="https://s2.loli.net/2023/05/03/5EzwoMeuVKYChLW.png" alt="字扩展.png"></p><h2 id="字位同时扩展"><a href="#字位同时扩展" class="headerlink" title="字位同时扩展"></a>字位同时扩展</h2><p><img src="https://s2.loli.net/2023/05/03/qdmUelVW1gnL9kz.png" alt="字位同时扩展.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 823 (Div. 2)C</title>
      <link href="/2023/05/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/05/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Minimum-Notation"><a href="#C-Minimum-Notation" class="headerlink" title="C. Minimum Notation"></a><a href="https://codeforces.com/problemset/problem/1730/C" title="C. Minimum Notation">C. Minimum Notation</a></h1><p>思路：我们可以进行的操作时将一个位置的数删除然后在任意位置处添加一个比当前数大1并且小于9的数，所以我们的操作只会让一个数变大，我们统计一个最大值的后缀，贪心的考虑如果当前数的后面有比他小的数的话，我们就需要让这个小的数往前走才能使字典序变小，如果当前值小于&lt;= 后缀的最小值，说明这个数后面的所有数往前移动都不能使字典序变得更小，所以我们统计完后缀后，从前往后扫一遍，用multiset维护以下，即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> c[N], suf[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> mn = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">strlen</span>(c + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = c[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(num &lt; mn)mn = num;</span><br><span class="line">suf[i] = mn;</span><br><span class="line">&#125; </span><br><span class="line">multiset&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = c[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(num &lt;= suf[i])s.<span class="built_in">insert</span>(num);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">9</span>)s.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">else</span>s.<span class="built_in">insert</span>(<span class="built_in">min</span>(num + <span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : s)cout &lt;&lt; x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内部类</title>
      <link href="/2023/05/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/05/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><blockquote><h4 id="一个类的内部又完整的嵌套了另一个类结构，被嵌套的类就被我们称为内部类，嵌套内部类的类被我们称为外部类"><a href="#一个类的内部又完整的嵌套了另一个类结构，被嵌套的类就被我们称为内部类，嵌套内部类的类被我们称为外部类" class="headerlink" title="一个类的内部又完整的嵌套了另一个类结构，被嵌套的类就被我们称为内部类，嵌套内部类的类被我们称为外部类"></a>一个类的内部又完整的嵌套了另一个类结构，被嵌套的类就被我们称为内部类，嵌套内部类的类被我们称为外部类</h4></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//内部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部其他类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">c1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h4><h5 id="1、定义在外部类局部位置上（比如方法内）"><a href="#1、定义在外部类局部位置上（比如方法内）" class="headerlink" title="1、定义在外部类局部位置上（比如方法内）"></a>1、定义在外部类局部位置上（比如方法内）</h5><h5 id="（1）局部内部类（有类名）"><a href="#（1）局部内部类（有类名）" class="headerlink" title="（1）局部内部类（有类名）"></a>（1）局部内部类（有类名）</h5><h2 id="（2）匿名内部类（没有类名）"><a href="#（2）匿名内部类（没有类名）" class="headerlink" title="（2）匿名内部类（没有类名）"></a>（2）匿名内部类（没有类名）</h2><h5 id="2、定义在外部类的成员位置上"><a href="#2、定义在外部类的成员位置上" class="headerlink" title="2、定义在外部类的成员位置上"></a>2、定义在外部类的成员位置上</h5><h5 id="（1）成员内部类（没用static修饰）"><a href="#（1）成员内部类（没用static修饰）" class="headerlink" title="（1）成员内部类（没用static修饰）"></a>（1）成员内部类（没用static修饰）</h5><h5 id="（2）静态内部类（使用static修饰）"><a href="#（2）静态内部类（使用static修饰）" class="headerlink" title="（2）静态内部类（使用static修饰）"></a>（2）静态内部类（使用static修饰）</h5><h1 id="1、局部内部类"><a href="#1、局部内部类" class="headerlink" title="1、局部内部类"></a>1、局部内部类</h1><blockquote><p>1、局部内部类是定义在外部类的方法中的<br>2、并且局部内部类可以访问外部类的所有成员包括私有的，访问的方法是直接访问，外部类在方法中可以创建内部类的对象，然后通过内部类的对象去调用其方法<br>3、不能添加访问修饰符，和局部变量一样，可以用final来修饰<br>4、作用域只在局部类的方法体内<br>5、外部其他类不能访问局部内部类（因为局部内部类的地位是一个局部变量）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Outer02</span> <span class="variable">outer02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer02</span>();</span><br><span class="line">        outer02.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//私有方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//局部内部类通常定义在外部类的方法中</span></span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner02</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//局部内部类可以访问外部类的所有成员，包含私有的</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                m2();</span><br><span class="line">                System.out.println(<span class="string">&quot;n1 = &quot;</span> + n1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner02</span> <span class="variable">inner02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner02</span>();</span><br><span class="line">        inner02.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>6、如果外部类和内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员可以使用（外部类名.this.成员）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out02.<span class="built_in">this</span>.n2</span><br></pre></td></tr></table></figure><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><blockquote><p>1、本质是类<br>2、内部类, 但实际是有名字的，只不过用完之后会立即被销毁<br>3、该类是没有名字<br>4、同时还是一个对象</p></blockquote><blockquote><h3 id="匿名内部类创建之后，会立马实例化出来，然后这个匿名类内部类就不能再被使用了，但实例化出来的对象是可以反复调用的"><a href="#匿名内部类创建之后，会立马实例化出来，然后这个匿名类内部类就不能再被使用了，但实例化出来的对象是可以反复调用的" class="headerlink" title="匿名内部类创建之后，会立马实例化出来，然后这个匿名类内部类就不能再被使用了，但实例化出来的对象是可以反复调用的"></a>匿名内部类创建之后，会立马实例化出来，然后这个匿名类内部类就不能再被使用了，但实例化出来的对象是可以反复调用的</h3></blockquote><h3 id="基于接口的匿名内部类使用"><a href="#基于接口的匿名内部类使用" class="headerlink" title="基于接口的匿名内部类使用"></a>基于接口的匿名内部类使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Outer04</span> <span class="variable">outer04</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer04</span>();</span><br><span class="line">        outer04.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer04</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//基于接口的匿名内部类</span></span><br><span class="line">        <span class="comment">//tiger的编译类型？IA</span></span><br><span class="line">        <span class="comment">//tiger的运行类型？就是匿名内部类</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            底层是</span></span><br><span class="line"><span class="comment">            class XXXX implements IA</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                public void cry()</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;老虎叫唤...&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老虎叫唤...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;tiger的运行类型 = &quot;</span> + tiger.getClass());</span><br><span class="line">        tiger.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2023.cnblogs.com/blog/3012367/202304/3012367-20230427103811618-2065452851.png" alt="image"></p><h3 id="基于类的匿名内部类"><a href="#基于类的匿名内部类" class="headerlink" title="基于类的匿名内部类"></a>基于类的匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Outer04</span> <span class="variable">outer04</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer04</span>();</span><br><span class="line">        outer04.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer04</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//基于接口的匿名内部类</span></span><br><span class="line">        <span class="comment">//tiger的编译类型？IA</span></span><br><span class="line">        <span class="comment">//tiger的运行类型？就是匿名内部类</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            底层是</span></span><br><span class="line"><span class="comment">            class XXXX implements IA</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                public void cry()</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;老虎叫唤...&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老虎叫唤...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;tiger的运行类型 = &quot;</span> + tiger.getClass());</span><br><span class="line">        tiger.cry();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常new一个对象</span></span><br><span class="line">        <span class="type">Father</span> <span class="variable">father1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;father1对象的运行类型是=&quot;</span> + father1.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了test方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;father对象的运行类型=&quot;</span> + father.getClass());</span><br><span class="line">        father.test();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小狗吃骨头&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        animal.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2023.cnblogs.com/blog/3012367/202304/3012367-20230427105440700-1340056105.png" alt="image"></p><h2 id="匿名内部类的使用细节"><a href="#匿名内部类的使用细节" class="headerlink" title="匿名内部类的使用细节"></a>匿名内部类的使用细节</h2><blockquote><h3 id="匿名内部类的定义比较特殊，本身是一个类同时还是一个对象"><a href="#匿名内部类的定义比较特殊，本身是一个类同时还是一个对象" class="headerlink" title="匿名内部类的定义比较特殊，本身是一个类同时还是一个对象"></a>匿名内部类的定义比较特殊，本身是一个类同时还是一个对象</h3></blockquote><h4 id="先定义一个匿名内部类，接收之后，再用生成的对象"><a href="#先定义一个匿名内部类，接收之后，再用生成的对象" class="headerlink" title="先定义一个匿名内部类，接收之后，再用生成的对象"></a>先定义一个匿名内部类，接收之后，再用生成的对象</h4><p><img src="https://img2023.cnblogs.com/blog/3012367/202304/3012367-20230427110459864-2046254694.png" alt="image"></p><h4 id="不接收直接调用"><a href="#不接收直接调用" class="headerlink" title="不接收直接调用"></a>不接收直接调用</h4><p><img src="https://img2023.cnblogs.com/blog/3012367/202304/3012367-20230427110559871-1909676952.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClassDetail</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Outer05</span> <span class="variable">outer05</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer05</span>();</span><br><span class="line">        outer05.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer05</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了hi&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        person.hi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//也可以直接调用</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了hi&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.hi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类的实践"><a href="#匿名内部类的实践" class="headerlink" title="匿名内部类的实践"></a>匿名内部类的实践</h3><blockquote><p>匿名内部类主要用于当前类只使用一次，使用过后我们就不会再反复使用，这样我们就没有必要专门再写一个类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span></span><br><span class="line">    &#123;</span><br><span class="line">       f1(<span class="keyword">new</span> <span class="title class_">IL</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;这是一幅名画&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(IL il)</span></span><br><span class="line">    &#123;</span><br><span class="line">        il.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IL</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassExercise02</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CellPhone cellPhone = <span class="keyword">new</span> <span class="built_in">CellPhone</span>();</span><br><span class="line">        cellPhone.<span class="built_in">alarmclock</span>(<span class="keyword">new</span> <span class="built_in">Bell</span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">ring</span>() &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;懒猪起床了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cellPhone.<span class="built_in">alarmclock</span>(<span class="keyword">new</span> <span class="built_in">Bell</span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">ring</span>() &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;小伙伴们上课&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Bell</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ring</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellPhone</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">alarmclock</span><span class="params">(Bell bell)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        bell.<span class="built_in">ring</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>1、成员内部类是定义在外部类的成员位置，并且没有static修饰。<br>2、成员内部类可以直接访问外部类的所有成员，包括私有成员。<br>3、外部类访问内部类，就是直接创建一个内部类然后通过类进行访问。<br>4、我们可以用public、private、protected去修饰，因为它本身就是一个成员<br>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberInnerClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        Outer08 outer08 = <span class="keyword">new</span> <span class="built_in">Outer08</span>();</span><br><span class="line">        outer08.<span class="built_in">t1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer08</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner08</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;n1 = &quot;</span> + n1 + <span class="string">&quot; name = &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">t1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner08 inner08 = <span class="keyword">new</span> <span class="built_in">Inner08</span>();</span><br><span class="line">        inner08.<span class="built_in">say</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>外部其他类使用成员内部类的两种方式<br>1、<br><img src="https://img2023.cnblogs.com/blog/3012367/202305/3012367-20230501134604393-795927860.png" alt="image"><br>2、<br><img src="https://img2023.cnblogs.com/blog/3012367/202305/3012367-20230501134840435-574862165.png" alt="image"></p></blockquote><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>比上个内部类多了一个static修饰符<br>1、静态内部类，在外部类的成员位置，有static修饰<br>2、可以访问外部类的所有静态成员，非静态不能访问<br>3、作用域为整个类体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer10</span> <span class="variable">outer10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer10</span>();</span><br><span class="line">        outer10.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer10</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="comment">//静态内部类，在外部类的成员位置，有static修饰</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以访问外部类的所有静态成员，非静态不能访问</span></span><br><span class="line">    <span class="comment">//作用域为整个类体</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner10</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner10</span> <span class="variable">inner10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner10</span>();</span><br><span class="line">        inner10.say();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
