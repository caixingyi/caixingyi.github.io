<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Educational Codeforces Round 148 [Rated for Div. 2]A~C</title>
      <link href="/2023/05/13/148-div2/"/>
      <url>/2023/05/13/148-div2/</url>
      
        <content type="html"><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a><a href="https://codeforces.com/contest/1832/problem/A">A</a></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">60</span>;</span><br><span class="line"><span class="type">char</span> c[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">strlen</span>(c + <span class="number">1</span>);</span><br><span class="line">map&lt;<span class="type">char</span>, <span class="type">int</span>&gt;st;</span><br><span class="line">st[c[<span class="number">1</span>]] ++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n / <span class="number">2</span>; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(st.<span class="built_in">find</span>(c[i]) == st.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="B"></a><a href="https://codeforces.com/contest/1832/problem/B">B</a></h1><p>直接枚举即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">LL s[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">LL ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">2</span> * (k - i), r = n - i;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, s[r] - s[l]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C"></a><a href="https://codeforces.com/contest/1832/problem/C">C</a></h1><p>C比赛时没出，思路上没什么大问题，就是差一点（bushi，说到底还是自己菜）<br>我们可以发现这道题只需要找一下有多少个波峰和波谷就可以了，因为波峰波谷一定不能删除</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]); </span><br><span class="line">n = <span class="built_in">unique</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>(); </span><br><span class="line"><span class="type">int</span> ans  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">0</span> || i == n <span class="number">-1</span> || a[i] &gt; a[i - <span class="number">1</span>] == a[i] &gt; a[i + <span class="number">1</span>])ans ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库的完整性</title>
      <link href="/2023/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7/"/>
      <url>/2023/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="完整性概述"><a href="#完整性概述" class="headerlink" title="完整性概述"></a>完整性概述</h1><p>数据库的完整性是指数据库的正确性、一致性、相容性<br>正确性：数据库的数据符合语义约束<br>一致性：数据间的逻辑关系是正确的，从一个一致性状态转移到另一个一致性状态<br>相容性：同一事物的两个数据应当是一致的<br>约束的分类</p><p>从约束的状态分类：<br>可以分为静态约束和动态约束<br>静态约束：数据库正确状态的约束<br>动态约束：数据库从一种正确状态转移到另一种状态的约束</p><h1 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h1><p>关系的主码唯一并且不能取空值<br>会破坏实体完整性的几种操作<br>1、向表中插入新元组会破坏实体完整性<br>2、修改元组的主码可能破坏实体完整性<br>3、违约处理，DBMS自动检查并且拒绝所有导致破坏实体完整性的任何插入和修改</p><h1 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h1><p>参照完整性是对外码取值的约束<br>外码的取值要么是其参照的表的主码的取值要么是空值（外码建立了不同关系的联系）<br>破坏参照完整性的几种情况<br>1、向参照关系中插入新元组<br>2、删除被参照关系中的元组<br>3、修改参照关系外码上的值<br>4、修改被参照关系上主码的值<br>违约处理：<br>1、拒绝<br>2、置空值<br>3、置默认值<br>4、级联<br><img src="https://s2.loli.net/2023/05/11/UbOkhSJRTpr65qi.png" alt="2.png"></p><h1 id="用户自定义的完整性"><a href="#用户自定义的完整性" class="headerlink" title="用户自定义的完整性"></a>用户自定义的完整性</h1><p>实体完整性和参照完整性是所有关系都必须遵守的，被称为关系的不变性<br>用户自定义的完整性可以分为属性级的、关系级的、数据库级的</p><h2 id="属性级的"><a href="#属性级的" class="headerlink" title="属性级的"></a>属性级的</h2><p>定义在列级上的属性约束CHECK约束、NULL约束、UNIQUE约束<br><img src="https://s2.loli.net/2023/05/11/cAjCsTNqyFKhoS1.png" alt="3.png"></p><h2 id="关系级的"><a href="#关系级的" class="headerlink" title="关系级的"></a>关系级的</h2><p>表级上的CHECK约束，涉及多个属性<br><img src="https://s2.loli.net/2023/05/11/eRMJrGX91atVOfk.png" alt="4.png"></p><h2 id="数据库级的"><a href="#数据库级的" class="headerlink" title="数据库级的"></a>数据库级的</h2><p>涉及多个关系的约束被称为数据库级的约束<br>断言Assertion是一种命名约束，他表达了数据库必须满足的逻辑状态</p><h3 id="断言的创建"><a href="#断言的创建" class="headerlink" title="断言的创建"></a>断言的创建</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span> <span class="keyword">CHECK</span> (<span class="operator">&lt;</span>约束条件<span class="operator">&gt;</span>) [<span class="operator">&lt;</span>约束性质<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><p>约束条件可以是涉及数据库对象的布尔表达式也可以是SELECT语句<br>约束性质可以是NOT DEEDERRABLE(不可延迟的)或DEEDERRABLE(可延迟的)，缺省时为不可延迟的（也就是说是约束立即检查）<br>eg：<br><img src="https://s2.loli.net/2023/05/11/PXYQKI7nrWOpvgJ.png" alt="5.png"><br>约束“任何部门经理的工资不超过其所在部门平均工资的10倍”涉及上述两个关系，可以为它创建一个断言，该约束等价于不存在一个部门经理，他的工资高于他所在部门平均工资的10倍“</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> ASSERTION SalaryConstraint <span class="keyword">CHECK</span></span><br><span class="line">(<span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">(<span class="keyword">SELECT</span> <span class="operator">*</span> Departments D, Employeess E</span><br><span class="line"><span class="keyword">WHERE</span> D.Mrgno <span class="operator">=</span> E.Eno <span class="keyword">AND</span></span><br><span class="line">Salary <span class="operator">&gt;</span> <span class="number">10</span> <span class="operator">*</span>(<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Salary)</span><br><span class="line"><span class="keyword">FROM</span> Employees</span><br><span class="line"><span class="keyword">WHERE</span> Dno <span class="operator">=</span> D.Dno)))</span><br></pre></td></tr></table></figure><p>断言被创建后，只有不违背断言的数据库更新才被允许，如果我们修改经理的工资，只有在满足上述断言，即工资不超过该部门平均工资的10倍的情况下才允许被更新</p><h3 id="断言的删除"><a href="#断言的删除" class="headerlink" title="断言的删除"></a>断言的删除</h3><p>如果没有其他数据库对象的定义依赖断言可用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> ASSERTION <span class="operator">&lt;</span>断言名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器名<span class="operator">&gt;</span> <span class="operator">&lt;</span>触发时间<span class="operator">&gt;</span> <span class="operator">&lt;</span>触发事件<span class="operator">&gt;</span> </span><br><span class="line"><span class="keyword">ON</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">REFERENCING</span> <span class="operator">&lt;</span>旧<span class="operator">/</span>新值别名<span class="operator">&gt;</span>. ...., <span class="operator">&lt;</span>旧<span class="operator">/</span>新值别名<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">FOR</span> <span class="keyword">EACH</span>&#123;<span class="type">ROW</span> <span class="operator">|</span> STATEMENT&#125;]</span><br><span class="line">[<span class="keyword">WHEN</span>(<span class="operator">&lt;</span>触发条件<span class="operator">&gt;</span>)]</span><br><span class="line"><span class="operator">&lt;</span>被触发的<span class="keyword">SQL</span>语句<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>REFERENCING子句创建一些过渡变量用来存放表T和表T的行更新前的旧值和更新后的新值。</p></blockquote><p>&lt;旧/新值别名&gt;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OLD</span> [<span class="type">ROW</span>] [<span class="keyword">AS</span>] <span class="operator">&lt;</span>变量<span class="operator">&gt;</span>:创建行过渡变量<span class="operator">&lt;</span>变量<span class="operator">&gt;</span>存放表T的行更新前的旧值</span><br><span class="line"><span class="keyword">NEW</span> [<span class="type">ROW</span>] [<span class="keyword">AS</span>] <span class="operator">&lt;</span>变量<span class="operator">&gt;</span>:创建行过渡变量<span class="operator">&lt;</span>变量<span class="operator">&gt;</span>存放表T的行更新后的新值</span><br><span class="line"><span class="keyword">OLD</span> <span class="keyword">TABLE</span> [<span class="keyword">AS</span>] <span class="operator">&lt;</span>变量<span class="operator">&gt;</span>:创建表过渡变量<span class="operator">&lt;</span>变量<span class="operator">&gt;</span>存放表T的行更新前的旧值</span><br><span class="line"><span class="keyword">NEW</span> <span class="keyword">TABLE</span> [<span class="keyword">AS</span>] <span class="operator">&lt;</span>变量<span class="operator">&gt;</span>:创建表过渡变量<span class="operator">&lt;</span>变量<span class="operator">&gt;</span>存放表T的行更新前的新值</span><br></pre></td></tr></table></figure><p>FOR EACH ROW:定义行级触发器<br>FOR EACH STATRMENT：定义语句级触发器</p><p>WHEN子句定义触发条件缺省时为无条件触发<br>&lt;被触发的SQL语句&gt;<br>形式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line"><span class="operator">&lt;</span>可执行的<span class="keyword">SQL</span>语句<span class="operator">&gt;</span>;</span><br><span class="line"><span class="operator">&lt;</span>可执行的<span class="keyword">SQL</span>语句<span class="operator">&gt;</span>;</span><br><span class="line"><span class="operator">&lt;</span>可执行的<span class="keyword">SQL</span>语句<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>删除触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="operator">&lt;</span>触发器<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟存储器</title>
      <link href="/2023/05/10/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/05/10/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>虚拟存储器是==主存-辅存==层次的，虚拟存储器主要是由操作系统实现，在计算机组成原理中应更加关注主存-Cache</p><h1 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h1><h2 id="1、实地址与虚地址"><a href="#1、实地址与虚地址" class="headerlink" title="1、实地址与虚地址"></a>1、实地址与虚地址</h2><p>1、实地址（物理地址）：计算机物理内存的访问地址。<br>2、虚地址（逻辑地址）：用户编程时使用的地址。<br>3、再定位：程序进行虚地址到实地址转换的过程。<br>4、虚地址空间与实地址空间的关系<br>虚地址空间可以远大于实地址空间，这时可以提高存储容量<br>虚地址空间可以远小于实地址空间，这时可以缩短指令值地址字段的长度</p><blockquote><p>虚拟存储器是概念模型不是实际的存储器</p></blockquote><h2 id="2、虚存的访问过程"><a href="#2、虚存的访问过程" class="headerlink" title="2、虚存的访问过程"></a>2、虚存的访问过程</h2><p><img src="https://s2.loli.net/2023/05/10/3VX28gHLkPoh4OQ.png" alt="510.1.png"></p><h2 id="3、Cache与虚存的异同"><a href="#3、Cache与虚存的异同" class="headerlink" title="3、Cache与虚存的异同"></a>3、Cache与虚存的异同</h2><p>主存-辅存与Cache-主存的访问机制类似<br>相同点是：<br>1、出发点相同，提高性能和容量、降低成本<br>2、原理相同：都是运用局部性原理<br>不同点<br>1、侧重点：Cache解决速度问题 、虚存解决容量问题<br>2、数据通路不通：CPU与Cache有直接通路而虚存所依赖的辅存和CPU并无直接通路<br>3、透明性不同：Cache均有硬件实现，对系统程序元和应用程序员均透明虚存对系统程序员不透明，对应用程序员透明<br>4、未命中时的损失不同，主存与Cache的访问时间、以及主存与辅存的访问时间，他们相差的时间远不相同</p><h2 id="3、虚存机制要解决的问题"><a href="#3、虚存机制要解决的问题" class="headerlink" title="3、虚存机制要解决的问题"></a>3、虚存机制要解决的问题</h2><p>1、调度问题<br>2、地址映射问题<br>3、替换问题<br>4、更新问题<br><img src="https://s2.loli.net/2023/05/10/z9eJOSogBGlm8bL.png" alt="510.2.png"></p><h1 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h1><p>首先我们要清楚页是什么？页是主存物理空间划分出来的等长区域又称页面，好了现在我们清楚了页的概念可以继续看下去。<br>那么什么叫页式管理呢？页式管理是对存储-辅存系统间采取的是以页为单位的信息传送<br>这种管理方式有他的优点和缺点，首先我们先看他的优点，优点是什么的？我们思考，这样分成一整块我们构造页表比较容易这样可以方便我们的管理，除了最后一页外，我们也没有浪费空间。<br>缺点其实也显而易见就是，因为分页是按空间大小分的，同一程序可能被分到两个或多个页内，不利于编程的独立性</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1、以页为基本单位构造出来的虚拟存储器称为页式虚拟存储器<br>2、逻辑页：虚地址空间被分成的页<br>3、物理页：实地址空间被分成同样大小的页<br><img src="https://s2.loli.net/2023/05/10/VtMPoNJHbfmG1uc.png" alt="510.3.png"></p><h2 id="页式虚存地址映射"><a href="#页式虚存地址映射" class="headerlink" title="页式虚存地址映射"></a>页式虚存地址映射</h2><p>虚地址和实地址之间的地址映射是通过页表来实现的<br>页表如下图所示：<br><img src="https://s2.loli.net/2023/05/10/lLI7M9tvXF6xDBe.png" alt="510.4.png"><br>虚拟地址的映射过程如下：<br>页表的基地址被存在一个寄存器中，我们通过虚存地址的逻辑页号以及页表基地址索引找到虚存地址页对应的物理页，然后物理页（作为实存地址的高字段）加上虚存地址的页内地址就是实存地址。<br><img src="https://img2023.cnblogs.com/blog/3012367/202305/3012367-20230510161416827-1430205353.png" alt="image"></p><h2 id="内页表和外页表"><a href="#内页表和外页表" class="headerlink" title="内页表和外页表"></a>内页表和外页表</h2><p>页表分为内页表和外页表<br>内页表：虚存和主存之间地址变换的表<br>外页表：虚存和辅存之间地址变换的表<br>主存缺页式要先定位到辅存</p><h2 id="转换后援缓冲器（TLB）"><a href="#转换后援缓冲器（TLB）" class="headerlink" title="转换后援缓冲器（TLB）"></a>转换后援缓冲器（TLB）</h2><p>1、把页表中最活跃的部分调入高速缓冲器<br>2、TLB是快表，而存放在主存中的完整页表被称为慢表</p><blockquote><p>TLB的作用类似与CPU主存之间的Cache<br><img src="https://s2.loli.net/2023/05/10/tZ8NnTAP75m9dg6.png" alt="510.6.png"></p></blockquote><h2 id="虚拟存储器、TBL、Cache的协同操作"><a href="#虚拟存储器、TBL、Cache的协同操作" class="headerlink" title="虚拟存储器、TBL、Cache的协同操作"></a>虚拟存储器、TBL、Cache的协同操作</h2><p>最好的情况是TBL命中，Cache也命中<br><img src="https://s2.loli.net/2023/05/10/RpXnEQI95fTxhHO.png" alt="510.7.png"></p><h1 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>1、段：按照程序的自然分界划分的长度可以动态改变的区域<br>2、段的优点：便于编译、管理修改和保护，段长可变，便于有效利用主存空间<br>3、缺点：主存分配空间比较麻烦，容易产生碎片空间</p><h2 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h2><p>通过段表<br><img src="https://s2.loli.net/2023/05/10/ektSDMHPFE8oxOz.png" alt="510.8.png"><br>段表的每个段表项至少包含以下3项<br>（1）、有效位<br>（2）、段起址<br>（3）、段长<br>段表图示如下：<br><img src="https://s2.loli.net/2023/05/10/iX71Egs4l5eMofN.png" alt="510.9.png"><br>虚地址映射过程如下：<br><img src="https://s2.loli.net/2023/05/10/17Srzg5UEFNIYn4.png" alt="510.10.png"></p><h1 id="段页式虚拟存储器（套娃）"><a href="#段页式虚拟存储器（套娃）" class="headerlink" title="段页式虚拟存储器（套娃）"></a>段页式虚拟存储器（套娃）</h1><p>段页式虚拟存储器是把程序按逻辑结构分段，每段再划分为固定大小的页<br>主存空间也划分为大小相等的页<br>每个程序对应一个段表，每段对应一个页表</p><blockquote><p>虚拟地址：段号+段内页号+页内地址</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/kdKJxaMDPyRQZBb.png" alt="510.11.png"><br><img src="https://s2.loli.net/2023/05/10/lFU3xKe5npECXqw.png" alt="510.12.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句</title>
      <link href="/2023/05/10/SQL%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/05/10/SQL%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="创建基本表"><a href="#创建基本表" class="headerlink" title="创建基本表"></a>创建基本表</h1><p>创建基本表要对表进行命名，定义表的每个列，定义表的完整性约束条件，我们使用CREATE TABLE语句创建基本表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [DEEAULT<span class="operator">&lt;</span>缺省值<span class="operator">&gt;</span>] [列级约束定义],</span><br><span class="line"><span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [DEEAULT<span class="operator">&lt;</span>缺省值<span class="operator">&gt;</span>] [列级约束定义],</span><br><span class="line"><span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [DEEAULT<span class="operator">&lt;</span>缺省值<span class="operator">&gt;</span>] [列级约束定义],</span><br><span class="line">...,</span><br><span class="line">[<span class="operator">&lt;</span>表级约束定义<span class="operator">&gt;</span>],...,<span class="operator">&lt;</span>表级约束定义<span class="operator">&gt;</span>);</span><br></pre></td></tr></table></figure><p>1、表名、列名均是由我们自己去定义的<br>2、数据类型即sql语言中给定的几种数据类型<br>3、缺省值是以后我们向数据库该的表中插入元素时，假如我们空缺了这一项，就会填上我们设置的缺省值<br>4、列级约束定义是对当前列的约束条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span>] <span class="operator">&lt;</span>列约束<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>列约束包括以下几种：<br>NOT NULL：不允许该列取空值；不加NOT NULL限制时，该列可以取空值<br>PRIMARYKEY：指明该列为主码，其值非空、唯一<br>UNIQUE：该列上的值唯一，说明改列为候选码<br>CHECK(&lt;条件&gt;)：指明该列的值必须满足的条件，&lt;条件&gt;为一个bool表达式</p></blockquote><h1 id="排序和分组"><a href="#排序和分组" class="headerlink" title="排序和分组"></a>排序和分组</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>ORDER BY子句可以将查询结果按一定的次序显示.<br>形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>排序列<span class="operator">&gt;</span> [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]&#123;, <span class="operator">&lt;</span>排序列<span class="operator">&gt;</span> [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]&#125;</span><br></pre></td></tr></table></figure><p>1、&lt;排序列&gt;是必须出现在SELECT语句中的属性名。<br>2、ORDER BY语句可以有一个或多个排序列，中间用逗号隔开。每个排序列都可以单独指定升序还是降序排列，==缺省==时为升序。<br>查询每位学生的每门课程的成绩，按成绩降序排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Cno <span class="operator">=</span> <span class="string">&#x27;CS202&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Grade <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>3、聚集函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">统计元组个数</span><br><span class="line"><span class="built_in">COUNT</span>([<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>]<span class="operator">*</span>)</span><br><span class="line">统计一列中值的个数</span><br><span class="line">COUNT（[<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] 列名）</span><br><span class="line">计算一列中值的个数</span><br><span class="line"><span class="built_in">SUM</span>([<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] 列名)</span><br><span class="line"><span class="built_in">AVG</span>([<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] 列名)</span><br><span class="line"><span class="built_in">MAX</span>([<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] 列名)</span><br><span class="line"><span class="built_in">MIN</span>([<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] 列名)</span><br></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>分组的关系和聚集函数的关系很大<br>GROUP BY语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span><span class="operator">&lt;</span>分组列<span class="operator">&gt;</span>[<span class="keyword">HAVING</span> <span class="operator">&lt;</span>分组选择条件<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>分组语句细化了聚集函数的作用范围<br>HAVING短语用来过滤掉不满足的&lt;分组选择条件&gt;的分组,缺省时等价于HAVING TRUE<br>&lt;分组选择条件&gt;类似于WHERE子句的查询条件，只不过WHERE子句中不允许出现聚集函数</p></blockquote><p>eg：查询每个学生的平均成绩，并输出平均成绩大于85的学生的学号和平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, <span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno <span class="keyword">HAVING</span> <span class="built_in">AVG</span>(Grade) <span class="operator">&gt;</span> <span class="number">85</span>;</span><br></pre></td></tr></table></figure><p>对于带GROUP BY子句的SELECT语句，SELECT子句中的结果列必须是GROUP BY子句中的&lt;分组列&gt;或聚集函数。</p><h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><p>Q:查询阿杜选修数据库系统原理课程的成绩？</p><blockquote><p>当查询需要的信息或者查询条件涉及的属性分布在多个表中时，需要进行链接查询</p></blockquote><p>1、SQL支持连接查询，允许FROM子句中包括多个表<br>2、当FROM子句中包含多个表时，相当于求这些表的笛卡尔积<br>3、可以在WHERE子句中说明连接条件，并通过SELECT子句选取所需要的属性来实现各种连接<br>eg:查询学号为201705001的学生的各科成绩，对每门课程显示课程名和成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Cname, Grade</span><br><span class="line"><span class="keyword">FROM</span> SC, Course</span><br><span class="line"><span class="keyword">WHERE</span> SC.Cno <span class="operator">=</span> Course.Cno <span class="keyword">AND</span> Sno <span class="operator">=</span> <span class="string">&#x27;2017050001&#x27;</span></span><br></pre></td></tr></table></figure><p>eg:查询每个学生的平均成绩，并输出平均成绩大于85的学生的学号、姓名和平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, <span class="built_in">AVG</span>(Grade)</span><br><span class="line"><span class="keyword">FROM</span> SC, Students</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno, Sname</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(Grade) <span class="operator">&gt;</span> <span class="number">85</span>;w</span><br></pre></td></tr></table></figure><h1 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h1><p>SQL是一种结构化查询语言，他允许将一个查询作为子查询嵌套在另一个SELECT语句中</p><blockquote><p>比较常见的嵌套是将查询结果嵌套在WHERE或HAVING语句中，子查询不能用ORDER BY语句，只有最终查询结果才能用ORDEFR BY语句</p></blockquote><h2 id="IN引出的子查询"><a href="#IN引出的子查询" class="headerlink" title="IN引出的子查询"></a>IN引出的子查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>元组<span class="operator">&gt;</span>[<span class="keyword">NOT</span>]<span class="keyword">IN</span><span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>eg：查询和林艳在同一专业学习的女同学的学号和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Sex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">AND</span> Speciality <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line">SELCET Speciality</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="operator">=</span> <span class="string">&#x27;林艳&#x27;</span>)；</span><br></pre></td></tr></table></figure><p>下面是先找到林艳的专业，然后将此专业作为查询条件</p><h1 id="集合的比较引出的查询"><a href="#集合的比较引出的查询" class="headerlink" title="集合的比较引出的查询"></a>集合的比较引出的查询</h1><p>SQL语言允许将一个元素与子查询的结果集进行比较。<br>形式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>值表达式<span class="operator">&gt;</span> Θ <span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">SOME</span> <span class="operator">|</span> <span class="keyword">ANY</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>其中&lt;值表达式&gt;通常是属性，Θ是比较运算符。SOME与ANY含义相同。早期只有ANY但是和英语上的any容易混淆，现在多用SOME。当&lt;子查询&gt;的结果为单个值时，ALL、SOME和ANY可以省略。<br>eg：<br>查询比软件工程专业所有学生都小的其他专业的学生的学号、姓名、专业和出生日期</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname, Speciality, <span class="keyword">year</span>(BIrthday)</span><br><span class="line"><span class="keyword">From</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Speciality <span class="operator">&lt;&gt;</span><span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">AND</span> <span class="keyword">year</span>(Birthday) <span class="operator">&gt;</span> <span class="keyword">ALL</span>(<span class="keyword">SELECT</span> <span class="keyword">year</span> (Birthday)</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Speciality <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>ALL 可以与聚集函数实现的查询互换</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname, Speciality, <span class="keyword">year</span>(Birthday)</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Speciality<span class="operator">&lt;&gt;</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">AND</span> </span><br><span class="line"><span class="keyword">year</span>(Birthday) <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(<span class="keyword">year</span>(Birthday)))</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Speciality <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/05/09/cpmd3PCs6yE7WV2.png" alt="image"></p><h1 id="存在量词引导的子查询"><a href="#存在量词引导的子查询" class="headerlink" title="存在量词引导的子查询"></a>存在量词引导的子查询</h1><p>形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXISTS</span> <span class="operator">&lt;</span>子查询<span class="operator">&gt;</span></span><br><span class="line">子查询的<span class="keyword">SELECT</span>子句的形式为<span class="keyword">SELECT</span><span class="operator">*</span>。<span class="keyword">EXISTS</span><span class="operator">&lt;</span>子查询<span class="operator">&gt;</span>为真，当且仅当<span class="operator">&lt;</span>子查询<span class="operator">&gt;</span>的结果非空（至少包含一个元组）</span><br></pre></td></tr></table></figure><blockquote><p>EXISTST是根据外层查询的每个元组依次取与内层查询的结果比较看是否为空，若非空则为真输出，反之则不输出，这是一个相关子查询。<br>这里我们可以把查询分为两种，一种是相关子查询，一种是不相关子查询。相关子查询就是内层查询依赖于外层查询，不相关子查询就是外层查询不依赖于内层查询</p></blockquote><p>感觉NOT EXISTS这里很绕还没有搞清楚，搞清楚再回来补这一点的内容和例子</p><h1 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>1、向基本表中插入单个元组</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T [(A1, ..., Ak)] <span class="keyword">VALUE</span>(c1, ..., ck)</span><br></pre></td></tr></table></figure><p>eg:<br>向Students表中添加一条这样的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Students</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;201716010&#x27;</span>, <span class="string">&#x27;司马相如&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">1997</span><span class="number">-01</span><span class="number">-28</span>, <span class="string">&#x27;2017&#x27;</span>, <span class="string">&#x27;计算数学&#x27;</span>, <span class="string">&#x27;MATh&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>A1，A2…可以不按顺序，只要与下面的值对应就可以，A1，A2等也可以省略，但这是下面的内容则必须按顺序</p></blockquote><p>2、插入查询结果<br>想基本表中插入单个元组一般用于数据的输入，我们有时候还想将查询结果插入到一个基本表中。插入查询结果的语句的基本形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T [(A1, A2, ..., Ak)]</span><br><span class="line"><span class="operator">&lt;</span>查询表达式<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>T通常是基本表，也可以是视图， A1，…,Ak是T的属性，&lt;查询表达式&gt;通常是一个SELECT语句</p></blockquote><p>eg:<br>信息工程学院要为本院每位教师办理一个校内就餐卡，直接用教师号作为主持人的编号，并预存100元，可以用INSERT语句插入到基本表中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Cardinf(Card<span class="operator">-</span><span class="keyword">no</span>, Name, Balance)</span><br><span class="line"><span class="keyword">SELECT</span> Tno, Tname, <span class="number">100.00</span></span><br><span class="line"><span class="keyword">FROM</span> Teachers</span><br><span class="line"><span class="keyword">WHERE</span> Dno <span class="operator">=</span> <span class="string">&#x27;IE&#x27;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意常量100.00出现在SELECT中。这使得查询结果的每个元组的第3列均取常量100.00。</p></blockquote><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>UPDATE语句格式为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> T</span><br><span class="line"><span class="keyword">SET</span> A1 <span class="operator">=</span> e1, ..., Ak <span class="operator">=</span> ek</span><br><span class="line">[<span class="keyword">WHERE</span><span class="operator">&lt;</span>修改条件<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><p>其中T通常是基本表，但也可以是某些视图，A1，…,Ak<br>是T的属性，而e1，…,ek是表达式,&lt;删除条件&gt;与SELECT语句中的查询条件类似</p><p>eg：将职工号为B050041的教师的职称修改为副教授</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Teachers</span><br><span class="line"><span class="keyword">SET</span> Title <span class="operator">=</span> <span class="string">&#x27;副教授&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Tno <span class="operator">=</span> <span class="string">&#x27;B050041&#x27;</span>;</span><br></pre></td></tr></table></figure><p>eg:将软件工程课程成绩低于60分的所有学生的软件工程成绩提高5分</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> SC</span><br><span class="line"><span class="keyword">SET</span> Grade <span class="operator">=</span> Grade <span class="operator">+</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">WHERE</span> Grade <span class="operator">&lt;</span> <span class="number">60</span> <span class="keyword">AND</span> Cno <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> Cno</span><br><span class="line"><span class="keyword">FROM</span> Course </span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>当关系表中的某些记录已经不再需要时，可以使用DELETE语句进行删除。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> T</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>删除条件<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><p>T通常是基本表，但也可以是某些视图<br>&lt;删除条件&gt;与SELECT语句中的查询条件</p><p>eg：删除学号为201824010的学生的记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> <span class="string">&#x27;201824010&#x27;</span></span><br></pre></td></tr></table></figure><p>eg:删除所有的学生的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Students</span><br></pre></td></tr></table></figure><blockquote><p>没有WHERE语句时条件恒真</p></blockquote><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图是从一个或多个基本表或视图导出的表，与基本不同的是视图的数据并不物理地存放在基本表中</p><h2 id="视图的创建和删除"><a href="#视图的创建和删除" class="headerlink" title="视图的创建和删除"></a>视图的创建和删除</h2><h3 id="视图的创建"><a href="#视图的创建" class="headerlink" title="视图的创建"></a>视图的创建</h3><p>形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>， ...,<span class="operator">&lt;</span>(列名)<span class="operator">&gt;</span>)]</span><br><span class="line"><span class="keyword">AS</span><span class="operator">&lt;</span>查询表达式<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure><p>&lt;视图名&gt;:标识符，我们自己命名<br>&lt;(列名)&gt;：&lt;查询表达式&gt;结果的诸列<br>&lt;查询表达式&gt;：通常是一个SELECET语句不包含DISTINCT短语和ORDER BY子句<br>[WITH CHECK OPTION]：表示该视图是可更新的<br>eg:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> SE_Students</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> Sno, Sname, Sex, Birthday, Dno</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Speciality <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></table></figure><blockquote><p>组成视图的属性列名要么全部省略要么全部指定。如果省略了视图的各个属性名，则有SELECT子句目标列中的各个字段组成。但在下列情况下必须明确指定组成视图的所有属性列名：<br>1、SELECT目标列中包含聚集函数或者列表达式<br>2、SELECT子句目标是’*’<br>3、多表连接时出现了同名属性列<br>4、需要为视图中某个列定义更合适的名字</p></blockquote><p>eg:建立软件工程专业学生的视图SE_Students,它包含Students中出Speciality之外的所有属性和软件工程专业所有学生的信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> SE_Students</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> Sno, Sname, Sex, Birthday, Dno</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line"><span class="keyword">WHERE</span> Speciality <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPTION;</span><br></pre></td></tr></table></figure><p>eg：基于多个表的视图<br>建立学生成绩视图Students_Grades,它包含如下属性：学号、学生姓名、课程名和成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Students_Grades(Sno, Sname, Cname, Grade)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> S.Sno, Sname, Cname, Grade</span><br><span class="line"><span class="keyword">FROM</span> Students S, SC, Courses C</span><br><span class="line"><span class="keyword">WHERE</span> S.Sno <span class="operator">=</span> SC.Sno <span class="keyword">AND</span> C.Cno <span class="operator">=</span> SC.Cno;</span><br></pre></td></tr></table></figure><h3 id="视图的删除"><a href="#视图的删除" class="headerlink" title="视图的删除"></a>视图的删除</h3><p>格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="operator">&lt;</span>视图名<span class="operator">&gt;</span> [CASCADE <span class="operator">|</span> RESTRICT]</span><br></pre></td></tr></table></figure><p>删除视图就是把视图的定义从数据字典中删除</p><h2 id="基于视图的查询"><a href="#基于视图的查询" class="headerlink" title="基于视图的查询"></a>基于视图的查询</h2><p>我们可以对视图进行查询，但最后都会消解为对基本表的查询<br>eg：查询软件工程专业的男生</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> SE_Students</span><br><span class="line"><span class="keyword">WHERE</span> Sex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line">上面的语句等价于下面的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>(<span class="keyword">SELECT</span> Sno, Sname, Sex, Birthday, Dno</span><br><span class="line"><span class="keyword">FROM</span> Students</span><br><span class="line">WGERE Speciality <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>)</span><br><span class="line"><span class="keyword">AS</span> SE_Students(Sno, Sname, Sex, Birthday, Dno)</span><br><span class="line"><span class="keyword">WHERE</span> Sex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="基于视图的更新"><a href="#基于视图的更新" class="headerlink" title="基于视图的更新"></a>基于视图的更新</h2><p>视图有可更新视图和不可更新视图<br>一般情况下行列子集视图都可以更新<br>eg：向软件工程专业的学生的视图SE_Students中插入一个新的记录，学号为201805109，姓名为阿杜，出生年月2023-05-10，女性，院系EI</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SE_Students(Sno, Sname, Birthday, Sex, Dno)</span><br><span class="line"><span class="keyword">VALUE</span>(<span class="string">&#x27;201805109&#x27;</span>, <span class="string">&#x27;阿杜&#x27;</span>, <span class="number">2023</span><span class="number">-05</span><span class="number">-10</span>,<span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;EI&#x27;</span>)</span><br></pre></td></tr></table></figure><p>eg；将软件工程专业学号为202105268的学生姓名改成‘李岩’</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> SE_Students</span><br><span class="line"><span class="keyword">SET</span> Sname <span class="operator">=</span> <span class="string">&#x27;李岩&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> <span class="string">&#x27;201805268&#x27;</span></span><br></pre></td></tr></table></figure><p>不可更新视图<br>S_G学生的平均成绩视图，没有办法透过视图来更改</p><h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><p>1、使用视图可以使一些查询表达更加简洁<br>2、视图提供了一定的逻辑独立性<br>3、视图可以起到安全保护作用<br>4、视图使得用户可以从不同的角度看待相同的数据</p><h1 id="嵌入式SQL"><a href="#嵌入式SQL" class="headerlink" title="嵌入式SQL"></a>嵌入式SQL</h1><p>SQL可以嵌入到C、JAVA等其他语言中，嵌入其他语言有一些问题需要解决<br>1、如何区分两种语言<br>2、两种语言的语句如何交换信息（通信）<br>3、如何连接数据库<br>下面以C语言为例</p><h2 id="（1）、"><a href="#（1）、" class="headerlink" title="（1）、"></a>（1）、</h2><h3 id="a、扩充主语言的编译系统，使之能处理SQL语句"><a href="#a、扩充主语言的编译系统，使之能处理SQL语句" class="headerlink" title="a、扩充主语言的编译系统，使之能处理SQL语句"></a>a、扩充主语言的编译系统，使之能处理SQL语句</h3><h3 id="b、在编译前先扫描源程序，将SQL语句翻译成目标代码"><a href="#b、在编译前先扫描源程序，将SQL语句翻译成目标代码" class="headerlink" title="b、在编译前先扫描源程序，将SQL语句翻译成目标代码"></a>b、在编译前先扫描源程序，将SQL语句翻译成目标代码</h3><blockquote><p>为了区分源程序中的SQL语句和诸语言语句，SQL规定：<br>所有嵌入式SQL语句都必须加前缀EXEC SQL</p></blockquote><h2 id="（2）、"><a href="#（2）、" class="headerlink" title="（2）、"></a>（2）、</h2><h3 id="a、SQLCODE"><a href="#a、SQLCODE" class="headerlink" title="a、SQLCODE"></a>a、SQLCODE</h3><p>1、每个SQL语句执行之后需要反馈一些状态信息，系统将这些状态信息存入SQLCODE<br>2、主语言语句可以访问SQLCODE，根据结果采取相应动作<br>3、SQLCODE是一个整型变量<br>如果SQL语句执行成功，SQLCODE = 0<br>如果执行结果无数据则SQLCODE = 100<br>其他情况视为异常，SQLCODE取负值，其具体值依赖于实现</p><h3 id="b、主语言变量"><a href="#b、主语言变量" class="headerlink" title="b、主语言变量"></a>b、主语言变量</h3><p>一般情况下主语言变量不能再SQL语言中使用<br>但是使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">BEGIN</span> <span class="keyword">DECLARE</span> SECTION;</span><br><span class="line">主语言变量;</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">END</span> <span class="keyword">DECLARE</span> SECTION;</span><br></pre></td></tr></table></figure><p>可以在SQL中使用</p><blockquote><p>为了区别SQL语句中出现的的主语言变量之前必须加冒号（：）</p></blockquote><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>游标的作用：<br>一个SQL语句得到的结果可能是多个记录，而主语言没办法一次处理多个记录，这就需要用到游标。<br>游标就是一个数据缓冲区，暂时存放SQL语句的执行结果<br>使用游标需要预先说明游标，在使用前打开游标，通过专门的SQL语句逐一提取记录，并在完成之后关闭游标</p><h2 id="如何连接数据库"><a href="#如何连接数据库" class="headerlink" title="如何连接数据库"></a>如何连接数据库</h2><p>c语言</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">CONNECT</span> <span class="keyword">TO</span> <span class="operator">&lt;</span><span class="keyword">SQL</span>服务器<span class="operator">&gt;</span>[<span class="keyword">AS</span><span class="operator">&lt;</span>连接名<span class="operator">&gt;</span>][<span class="keyword">USER</span><span class="operator">&lt;</span>用户名<span class="operator">&gt;</span>];</span><br><span class="line">``</span><br><span class="line">建立到当前服务器的默认连接</span><br><span class="line">```<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQl</span> <span class="keyword">CONNECT</span> <span class="keyword">TO</span> <span class="keyword">DEFAULT</span>;</span><br></pre></td></tr></table></figure><p>关闭数据库连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> DISCONNECTION <span class="operator">&lt;</span>连接名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h1 id="不使用游标的SQL语句"><a href="#不使用游标的SQL语句" class="headerlink" title="不使用游标的SQL语句"></a>不使用游标的SQL语句</h1><p>有些SQL语句不产生结果，这些SQL语句可以不适用游标<br>说明型语句、数据定义语句、数据控制语句、SQL产生的结果不是元组的集合，主语言可以一次处理那么也不需要游标<br>（例如查询结果为单个记录的SELECT语句）、非交互的语句</p><h2 id="1、查询结果为单个记录的SELECT语句"><a href="#1、查询结果为单个记录的SELECT语句" class="headerlink" title="1、查询结果为单个记录的SELECT语句"></a>1、查询结果为单个记录的SELECT语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">SELECT</span> <span class="operator">&lt;</span>选择序列<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">INTO</span> <span class="operator">&lt;</span>选择目标序列<span class="operator">&gt;</span></span><br><span class="line">其他子句</span><br></pre></td></tr></table></figure><p>eg:查询给定学生的给定课程成绩<br>假设学生的学号已经赋予主变量Hsno，课程号已经赋值给主变量Hcno，则下面语句将检索相应的成绩，并将结果赋予主变量Hgrade：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">SELECT</span> Grade</span><br><span class="line"><span class="keyword">INTO</span>:Hgrade:igrade</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span>:Hsno <span class="keyword">AND</span> Cno <span class="operator">=</span>:Hcno;</span><br></pre></td></tr></table></figure><h2 id="非交互式更新"><a href="#非交互式更新" class="headerlink" title="非交互式更新"></a>非交互式更新</h2><p>删除一个学生的记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL DELETE FROM SC </span><br><span class="line">WHERE Sno =:Hsno;</span><br><span class="line">EXEC SQL DELETE FROM Students </span><br><span class="line">WHERE Sno =:Hsno;</span><br></pre></td></tr></table></figure><h1 id="使用游标的SQL"><a href="#使用游标的SQL" class="headerlink" title="使用游标的SQL"></a>使用游标的SQL</h1><p>使用游标的SQOL语句有如下两种情况<br>1、查询结果为多个元组的SELCET语句<br>2、交互式更新语句</p><blockquote><p>所有使用游标的SQL语句都必须先通过<br>1、说明定义游标<br>2、在使用前打开游标<br>3、反复推进游标指针并取当前记录进行处理<br>4、最后，当所有记录都处理完之后，关闭游标</p></blockquote><p>说明游标使用DECLARE语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">DECLARE</span> <span class="operator">&lt;</span>游标名<span class="operator">&gt;</span> <span class="keyword">CURSOR</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="operator">&lt;</span><span class="keyword">SELECT</span>语句<span class="operator">&gt;</span></span><br><span class="line">[<span class="operator">&lt;</span>可更新性子句<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><p>1、游标的内容由打开游标时执行定义游标的&lt;SELECT语句&gt;决定<br>2、有一个与游标相关联的指针，初始时它指向游标第一行之前的位置<br>[&lt;可更新性子句&gt;]：有两种形式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOR</span> READ <span class="keyword">ONLY</span></span><br></pre></td></tr></table></figure><p>定义只读游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOR</span> <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span>，..., <span class="operator">&lt;</span>列名<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><p>定义可更新游标</p><p>缺省时为只读型游标</p><h2 id="可更新型游标"><a href="#可更新型游标" class="headerlink" title="可更新型游标"></a>可更新型游标</h2><p>对于可更新型游标，使用CURRENT形式的UPDATE和DELETE语句进行更新，对游标的更新转换成对定义游标的基本表的更新，所以SELECT语句定义的表必须是可更新的</p><h2 id="游标的两种状态"><a href="#游标的两种状态" class="headerlink" title="游标的两种状态"></a>游标的两种状态</h2><h3 id="游标的打开"><a href="#游标的打开" class="headerlink" title="游标的打开"></a>游标的打开</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">OPEN</span> <span class="operator">&lt;</span>游标名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="关闭游标"><a href="#关闭游标" class="headerlink" title="关闭游标"></a>关闭游标</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">CLOSE</span> <span class="operator">&lt;</span>游标名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="推进游标指针并取当前记录"><a href="#推进游标指针并取当前记录" class="headerlink" title="推进游标指针并取当前记录"></a>推进游标指针并取当前记录</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">FETCH</span> [[<span class="operator">&lt;</span>推进方向<span class="operator">&gt;</span>] <span class="keyword">FROM</span>] <span class="operator">&lt;</span>游标名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">INTO</span>:<span class="operator">&lt;</span>主变量<span class="operator">&gt;</span>[:<span class="operator">&lt;</span>指示变量<span class="operator">&gt;</span>,...,:<span class="operator">&lt;</span>主变量<span class="operator">&gt;</span>[:<span class="operator">&lt;</span>指示变量<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>&lt;推进方向&gt;:NEXT：向前推进一个记录<br>PRIOR：向后推进一个进路<br>FIRST：推进到第一个记录<br>LAST：推进到最后一个记录<br>缺省值为NEXT<br>INTO子句中的主变量必须与说明游标中的SELECT语句中的目标列表达式一一对应</p></blockquote><h3 id="Current形式的更新语句"><a href="#Current形式的更新语句" class="headerlink" title="Current形式的更新语句"></a>Current形式的更新语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> T</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> <span class="operator">&lt;</span>游标<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> T</span><br><span class="line"><span class="keyword">SET</span> A1 <span class="operator">=</span> e1, ..., Ak <span class="operator">=</span> ek</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span><span class="operator">&lt;</span>游标名<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>eg:从Students和SC中删除某学生的记录：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> YN;<span class="comment">//变量YN不在SQL语句中使用</span></span><br><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line"><span class="type">char</span> Givenname[<span class="number">8</span>];</span><br><span class="line"><span class="type">char</span> Hson[<span class="number">9</span>];</span><br><span class="line"><span class="type">char</span> Hsname[<span class="number">9</span>];</span><br><span class="line"><span class="type">char</span> Hsex[<span class="number">9</span>];</span><br><span class="line"><span class="type">char</span> Henrollyear[<span class="number">9</span>];</span><br><span class="line"><span class="type">char</span> Hspeciality[<span class="number">9</span>];</span><br><span class="line"><span class="type">char</span> Hdno[<span class="number">9</span>];</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line">EXEC SQL DECLARE Stydent_Cursor CURSOR FOR </span><br><span class="line">SELECT Sno, Sname, Sex, Enrollyear, Speciality, Dno</span><br><span class="line">FROM Students</span><br><span class="line">WHERE Sname=:Givenname</span><br><span class="line">FOR UPDATE;</span><br><span class="line">Givenname=<span class="string">&#x27;李明&#x27;</span>;</span><br><span class="line">EXEC SQL OPEN Student_Cursor;</span><br><span class="line">EXEC SQL FETCH Students_Coursor;</span><br><span class="line"><span class="keyword">while</span>(SQLCODE = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s %s % s % s %是\n&quot;</span>, Hsno, Hsname, Hsex, Henrollyear, Hspeciality, Hdno);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;YN);</span><br><span class="line"><span class="keyword">if</span>(YN == <span class="string">&#x27;y&#x27;</span> || YN == <span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">EXEC SQL DELETE FROM SC</span><br><span class="line">WHERE Sno = :Hsno;</span><br><span class="line">EXEC SQL DELETE FROM Students</span><br><span class="line">WHERE CURRENT OF Students_Cursor;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXEC SQL FETCH Student_Cursor</span><br><span class="line">INTO:Hsno,:Hsname,:Hsex, :Henrollyear, Hspeciality,:Hdno;</span><br><span class="line">&#125;</span><br><span class="line">EXEC SQL CLOSE Student_Cursor;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Acwing周赛102</title>
      <link href="/2023/05/08/Acwing%E5%91%A8%E8%B5%9B102/"/>
      <url>/2023/05/08/Acwing%E5%91%A8%E8%B5%9B102/</url>
      
        <content type="html"><![CDATA[<h1 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a><a href="https://www.acwing.com/problem/content/4979/">倍增</a></h1><p>这是一道简单数论题</p><figure class="highlight plaintext"><figcaption><span><bits/stdc++.h></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line">const int N = 1e5 + 10;</span><br><span class="line"></span><br><span class="line">int a[N], n;</span><br><span class="line"></span><br><span class="line">int div(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(x % 2 == 0)</span><br><span class="line">        while(x % 2 == 0)    x /= 2;</span><br><span class="line">    if(x % 3 == 0)</span><br><span class="line">        while(x % 3 == 0)    x /= 3;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 1; i &lt;= n; ++ i)    scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">    for(int i = 1; i &lt;= n; ++ i)    a[i] = div(a[i]);</span><br><span class="line">    for(int i = 1; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(a[1] != a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;</span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三元组"><a href="#三元组" class="headerlink" title=" 三元组"></a><a href="https://www.acwing.com/problem/content/4980/"> 三元组</a></h1><p>这道题目我们可以直接用stlmap套vector+stl的二分暴力来做也可以选择用前后缀分解，前后缀分解是我第一次见这种思想，会用一篇博客单独整理运用这种思想的题目</p><blockquote><p>stl直接做</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">LL ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    map&lt;LL, vector&lt;<span class="type">int</span>&gt;&gt;mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        mp[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ay = a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i] % k == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LL ax = ay / k, az = <span class="number">1LL</span> * ay * k;</span><br><span class="line">            <span class="keyword">if</span>(mp.<span class="built_in">find</span>(ax) != mp.<span class="built_in">end</span>() &amp;&amp; mp.<span class="built_in">find</span>(az) != mp.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; v1 = mp[ax];</span><br><span class="line">                <span class="keyword">auto</span>&amp; v2 = mp[az];</span><br><span class="line">                <span class="type">int</span> m = v2.<span class="built_in">size</span>();</span><br><span class="line">                <span class="type">int</span> k1 = <span class="built_in">lower_bound</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), i) - v1.<span class="built_in">begin</span>();</span><br><span class="line">                <span class="keyword">if</span>(k1 &gt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    -- k1;</span><br><span class="line">                    <span class="type">int</span> k2 = <span class="built_in">upper_bound</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), i) - v2.<span class="built_in">begin</span>();</span><br><span class="line">                    ans += <span class="number">1LL</span> * (k1 + <span class="number">1</span>) * (m - k2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>前后缀分解去做</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">LL a[N];</span><br><span class="line">map&lt;LL, LL&gt;l, r;</span><br><span class="line">LL ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">        r[a[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        r[a[i]] --;</span><br><span class="line">        <span class="keyword">if</span>(a[i] % k == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l.<span class="built_in">find</span>(a[i] / k) != l.<span class="built_in">end</span>() &amp;&amp; r.<span class="built_in">find</span>(a[i] * k) != r.<span class="built_in">end</span>()) </span><br><span class="line">                ans += <span class="number">1LL</span> * l[a[i] / k] * r[a[i] * k];</span><br><span class="line">        &#125;</span><br><span class="line">        l[a[i]] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Acwing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 前后缀分解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型</title>
      <link href="/2023/05/08/Java%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/05/08/Java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型使用"><a href="#泛型使用" class="headerlink" title="泛型使用"></a>泛型使用</h1><p>泛型的本质是参数化类型<br>1、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt;&#123;&#125; <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><p>T和E必须是引用类型不能是基本类型<br>2、使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//后面可以直接缺省java编译器会帮我们自动推断</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>3、如果不写默认为Object类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br></pre></td></tr></table></figure><h1 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h1><h2 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h2><p>语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class&lt;T, E,&gt; 类名&#123;&#125;</span><br></pre></td></tr></table></figure><p>1、普通成员均可以使用泛型<br>2、静态成员不能使用泛型<br>3、泛型数组不能初始化<br>4、泛型的类型是在创建对象时确定的</p><h2 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h2><p>语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名 &lt;T, E,&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>1、接口中的静态成员也不能使用泛型<br>2、接口中的泛型在继承接口或实现接口时确定类型<br>3、没有指定类型，默认Object</p><h2 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h2><p>语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T, E,&gt; 返回类型 方法名（参数列表） &#123;&#125;</span><br></pre></td></tr></table></figure><p>1、泛型方法可以定义在普通类】也可以定义在泛型类<br>2、泛型方法在被调用时确定其类型<br>3、注意区别，方法使用泛型和泛型方法</p><h1 id="泛型的继承和通配"><a href="#泛型的继承和通配" class="headerlink" title="泛型的继承和通配"></a>泛型的继承和通配</h1><p>1、泛型不具备继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;:可以接收任何类型</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Employee</span>&gt;:可以接收Employee的子类（包括非直接子类）</span><br><span class="line">List&lt;? <span class="built_in">super</span> Employee&gt;:可以接收Employee的父类（包括非直接父类）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 848 (Div. 2)B</title>
      <link href="/2023/05/06/848-div2-B/"/>
      <url>/2023/05/06/848-div2-B/</url>
      
        <content type="html"><![CDATA[<h1 id="B-The-Forbidden-Permutation"><a href="#B-The-Forbidden-Permutation" class="headerlink" title="B. The Forbidden Permutation"></a><a href="https://codeforces.com/contest/1778/problem/B">B. The Forbidden Permutation</a></h1><blockquote><p>一定要注意题目中说的是对于all i满足才算不好的，我们做的时候只要破坏一个i这个a就不算好的了,被这一点坑了，没注意到all。</p></blockquote><p>我们只需要从前往后做一遍，对于满足题中不等式的a[i]我们的操作是把a[i + 1]移到a[i]前面，一种操作是，将a[i + 1]向后移直到破坏后面的条件，（注意不能移出边界）<br>最后两种操作取最小值即可，如果我们未操作时题目中就有不满足的a[i]，此时答案就为0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> p[N], a[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span> p);</span><br><span class="line"><span class="type">int</span> n, m, d;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;d);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">p[x] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[a[i + <span class="number">1</span>]] &lt; p[a[i]] || p[a[i + <span class="number">1</span>]] &gt; p[a[i]] + d)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p[a[i + <span class="number">1</span>]] &gt; p[a[i]])ans = <span class="built_in">min</span>(ans, p[a[i + <span class="number">1</span>]] - p[a[i]]);</span><br><span class="line"><span class="keyword">if</span>(p[a[i + <span class="number">1</span>]] &lt;= p[a[i]] + d)</span><br><span class="line"><span class="keyword">if</span>(d + <span class="number">2</span> &lt;= n)ans = <span class="built_in">min</span>(ans, p[a[i]] + d + <span class="number">1</span> - p[a[i + <span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 856 (Div. 2)C</title>
      <link href="/2023/05/06/856-div2-C/"/>
      <url>/2023/05/06/856-div2-C/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Scoring-Subsequences"><a href="#C-Scoring-Subsequences" class="headerlink" title="C. Scoring Subsequences"></a><a href="https://codeforces.com/problemset/problem/1794/C">C. Scoring Subsequences</a></h1><p>思路：我们想要找到满足的最大值的长度最长的的区间，因为单调不减，所以更大的数一定在最大值的里面包含，所以我们用两个指针维护这样一个满足当前i的最大值区间，当新来一个数，这时我们答案里面一定要包含这个数，我们看能否保持这个长度，能不能保持需要看j指针所指的数/区间长度和1的大小比较，如果大于1乘上去一定可以使结果增大，反之会使结果减小，那么这个数就不能要了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N]; </span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(j &lt;= i &amp;&amp; a[j] / (i - j + <span class="number">1</span>) &lt; <span class="number">1</span>)++ j;</span><br><span class="line">cout &lt;&lt; i - j + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeTON Round 4 (Div. 1 + Div. 2)C</title>
      <link href="/2023/05/06/CodeTON-Round-4-Div-1-Div-2-C/"/>
      <url>/2023/05/06/CodeTON-Round-4-Div-1-Div-2-C/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Make-It-Permutation"><a href="#C-Make-It-Permutation" class="headerlink" title="C. Make It Permutation"></a><a href="https://codeforces.com/contest/1810/problem/C">C. Make It Permutation</a></h1><p>我们希望尽可能少地进行操作可以使代价最小，我们如果要排列的话，那些重复的元素我们无论如何都要进行删除的，所以我们可以先把去重的代价计算出来，然后依次枚举排列的位数是多少，也就是枚举去重后的数组，其中的代价我们可以一次计算出来，当我们枚举第i个a时，前面1有 i - 1个数，而1~ai - 1所有数都需要有，所以一共需要补ai - i个数，而i后面所有数都需要删除需要删m - i个数，代价我们可以通过O（1）的时间复杂度计算出来，然后枚举i更新答案即可。</p><p>时间复杂度：O（n）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> c[N]; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line">LL val = <span class="number">0</span>, ans = <span class="number">2e18</span>;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">find</span>(x) == s.<span class="built_in">end</span>())s.<span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">else</span> val += a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it : s)c[++ m] = it;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL k = <span class="number">1LL</span> * (c[i] - i) * b + <span class="number">1LL</span> * (m - i) * a;</span><br><span class="line">ans = <span class="built_in">min</span>(k, ans);</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">min</span>(ans, <span class="number">1LL</span> * m * a + b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, val + ans);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 865 (Div. 1)A</title>
      <link href="/2023/05/05/865-div1-A/"/>
      <url>/2023/05/05/865-div1-A/</url>
      
        <content type="html"><![CDATA[<h1 id="A-Ian-and-Array-Sorting"><a href="#A-Ian-and-Array-Sorting" class="headerlink" title="A. Ian and Array Sorting"></a><a href="https://codeforces.com/problemset/problem/1815/A">A. Ian and Array Sorting</a></h1><p>思路：首先我们可以从前往后做一遍，把除了最后一个元素其他所有数都变成和第一个数一样的数，然后假如前n-1个数个数为偶数，这样我们分组进行操作，一定可以把所有数变成无限小，也就是说一定会有解，也就是说n为奇数一定有解，我们考虑n为偶数的情况，n为偶数，我们从前往后做一遍，前n-1个数相同，前n-2个数一定可以变为无穷小，所以我们只需要比较最后两个数也就是n-1和n的大小即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;LL&gt;a, b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a.<span class="built_in">clear</span>();</span><br><span class="line">b.<span class="built_in">clear</span>();</span><br><span class="line"><span class="type">int</span> n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL x;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">a.<span class="built_in">push_back</span>(x);</span><br><span class="line">b.<span class="built_in">push_back</span>(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">bool</span> success = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line"><span class="keyword">if</span>(a[i] != b[i])success = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(success)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n &amp; <span class="number">1</span>)<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + <span class="number">1</span> &lt; n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">LL d = a[i - <span class="number">1</span>] - a[i];</span><br><span class="line">a[i] += d;</span><br><span class="line">a[i + <span class="number">1</span>] += d;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(a[n - <span class="number">2</span>] &lt;= a[n - <span class="number">1</span>])<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">else</span><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 866 (Div. 1)A</title>
      <link href="/2023/05/05/866-div1-A/"/>
      <url>/2023/05/05/866-div1-A/</url>
      
        <content type="html"><![CDATA[<h1 id="A-Constructive-Problem"><a href="#A-Constructive-Problem" class="headerlink" title="A. Constructive Problem"></a><a href="https://codeforces.com/problemset/problem/1819/A">A. Constructive Problem</a></h1><p>题意：给定一个长度为n的非负数组a，我们可以进行一次操作，操作是将l~r这个区间内的所有数变为k（k &gt;= 0），得到b，能不能使mex（a）+ 1 = mex（b）</p><p>思路：我是先排了个序，去了一下重，然后得到的这个数组其实只有两种情况<br><img src="https://s2.loli.net/2023/05/05/JIwPBDQqVZ5FliK.jpg" alt="7fadb345668574e200b410c44f14b05.jpg"><br><img src="https://s2.loli.net/2023/05/05/17OtNERXlZaFKV3.jpg" alt="cdc76ad46ad0e20e462b088d676162b.jpg"><br>一种每两个数之间的增量为1<br>一种是每两个数之间的增量大于1<br>对于第一种情况<br>我们考虑原数组大小如果和去重后数组大小相同，这种情况是不能增大的<br>否则说明有重复元素，我们只需要将重复元素变为n+1即可也就是说一定有解<br>对于第二种情况<br>我们考虑第一个增量不为一的地方<br>假如这个地方的增量为2这样我们就需要将这包含这个数的最小区间内的所有数变成mex（a）+1<br>然后扫一遍check以下就做完了<br>假如第一个增量不为一的地方的增量&gt;=3则一定有解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">b.<span class="built_in">clear</span>();</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), b.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; a[<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">b.<span class="built_in">erase</span>(<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(b[<span class="number">0</span>] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b.<span class="built_in">size</span>() - <span class="number">1</span> == b[b.<span class="built_in">size</span>() - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n == b.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i] != i)<span class="keyword">break</span>;</span><br><span class="line">t = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b[t + <span class="number">1</span>] - b[t] &gt;= <span class="number">3</span>)<span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] == b[t + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">l = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] == b[t + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">r = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;mp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt;= l &amp;&amp; i &lt;= r)<span class="keyword">continue</span>;</span><br><span class="line">mp[a[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= b[t]; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(mp.<span class="built_in">find</span>(i) == mp.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高速存储器</title>
      <link href="/2023/05/05/%E9%AB%98%E9%80%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2023/05/05/%E9%AB%98%E9%80%9F%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="双端口存储器"><a href="#双端口存储器" class="headerlink" title="双端口存储器"></a>双端口存储器</h1><h2 id="双端口处理器的逻辑结构"><a href="#双端口处理器的逻辑结构" class="headerlink" title="双端口处理器的逻辑结构"></a>双端口处理器的逻辑结构</h2><p>1、一个存储器具有两组相互独立的读写控制电路。<br>2、两个端口具有独立的数据线、读写线、控制线。<br>3、两个端口可对存储器中任何位置上的数据进行独立的存取操作</p><p><img src="https://s2.loli.net/2023/05/04/wY41XTghCbZ3f7k.png" alt="双端口处理器逻辑图.png"></p><h2 id="双端口处理器的读写"><a href="#双端口处理器的读写" class="headerlink" title="双端口处理器的读写"></a>双端口处理器的读写</h2><h3 id="无冲突读写"><a href="#无冲突读写" class="headerlink" title="无冲突读写"></a>无冲突读写</h3><p>当两个端口的地址不同时，在两个端口上进行读写操作一定不会发生冲突</p><h3 id="有冲突读写"><a href="#有冲突读写" class="headerlink" title="有冲突读写"></a>有冲突读写</h3><p>两个端口同时读写一个地址时便可能发生冲突，这是我们通过设置一个BUSY标志来解决冲突</p><h1 id="多模块交叉存储器"><a href="#多模块交叉存储器" class="headerlink" title="多模块交叉存储器"></a>多模块交叉存储器</h1><h2 id="存储器的模块化组织"><a href="#存储器的模块化组织" class="headerlink" title="存储器的模块化组织"></a>存储器的模块化组织</h2><p>多体并行存储器也能解决cpu速度与存储器速度不匹配的问题</p><blockquote><p>这里存取我们都考虑的是存取连续空间里的数据，因为我们通常的数据、代码、指令还有数组等这些东西，都是在连续的地址空间里进行存储的，也就是说大部分情况我们访存都是访问的连续地址</p></blockquote><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>假如我们现在要访问一段连续地址（00000~00100），我们访问00000后需要等待T（存储器的存取周期）后才能进行下一次访问00001<br><img src="https://s2.loli.net/2023/05/04/vbKj1spVgtZ8ldN.png" alt="顺序方式.png"><br>所以我们需要的总时间就如下：<br>5T<br><img src="https://s2.loli.net/2023/05/04/DmlbYJIwp83ykKs.png" alt="高位交叉编址.png"></p><h3 id="交叉存储"><a href="#交叉存储" class="headerlink" title="交叉存储"></a>交叉存储</h3><p>而交叉存储时，我们访问一段连续地址，当我们访问00000之后，00000所在存储体进入恢复阶段，我们可以接着访问00001，因为他们不在一个存储体中，而访问玩00001后，我们可以直接访问00010，这样前两个存储题都进行了恢复，所以通过这种交叉存储可以实现流水线式的并行工作</p><p><img src="https://s2.loli.net/2023/05/04/MNU8kVIZj43zerb.png" alt="交叉存储.png"><br>所以低位交叉存储的时间如下：<br>这里我们假设T=4r，T为存取周期，r为cpu取数的时间，也就是说，当我们访问完最后一个存储体后，第一个存储体就又恢复好了，我们就可以接着对第一个存储体进行访问了,<br>读取n个字所需的时间为<br>t = T + (n - 1)r<br><img src="https://s2.loli.net/2023/05/04/kZ65tVuBNy3fYKr.png" alt="低位交叉存储.png"></p><h4 id="低位交叉存储中我们需要设计多少个存储体合适呢？"><a href="#低位交叉存储中我们需要设计多少个存储体合适呢？" class="headerlink" title="低位交叉存储中我们需要设计多少个存储体合适呢？"></a>低位交叉存储中我们需要设计多少个存储体合适呢？</h4><p>我们应该保证存储体个数m &gt;= T / r，这是什么原因呢？<br>我们可以这样考虑，当T / r表示一个存储体从访问开始到下次再能访问需要有几个存储体可以<br>当存储体个数比较少时，cpu访问完所有存储体后，第二次访问第一次访问的存储体，这时这个存储体还没有恢复好，cpu需要等待其恢复好，才能进行访问，而当m个数比较多时，cpu还没有再次访问到第一次访问的存储体，他就已经回复好了，这是存储体就需要等待cpu<br>所以最好的状态是cpu刚好访问一遍存储体，最初访问的存储体刚刚恢复好，这样既没有产能过剩也没有有人偷懒的情况<br><img src="https://s2.loli.net/2023/05/04/fxIncuETp7s6Oaq.png" alt="未充分利用.png"><br><img src="https://s2.loli.net/2023/05/04/V5ND7cSLOHQWh6i.png" alt="产能过剩.png"><br><img src="https://s2.loli.net/2023/05/04/BYAfzMdJF1D8co5.png" alt="比较完美.png"></p><h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><h2 id="Cache概述"><a href="#Cache概述" class="headerlink" title="Cache概述"></a>Cache概述</h2><h3 id="Cache的功能"><a href="#Cache的功能" class="headerlink" title="Cache的功能"></a>Cache的功能</h3><p>1、Cache是为了解决CPU与主存之间速度不匹配的一项技术<br>2、介于CPU和主存之间的一种小容量的高速缓冲器<br>3、基于局部性原理<br>4、全部功能由硬件实现，对程序员透明</p><h3 id="Cache的基本原理"><a href="#Cache的基本原理" class="headerlink" title="Cache的基本原理"></a>Cache的基本原理</h3><p>CPU与Cache之间的数据交换是以字为单位的，而Cache和主存之间的数据交换是以块为单位的。一个块是由若干字组成的。当CPU需要读取内存中的一个字时，就会发出这个字的内存地址到Cache和主存。此时Cache控制逻辑依据地址判断此字目前是否在Caxhe中。若在，则此字立刻传送给CPU若不在，则用主存读周期读出送入CPU，并且不含有这个字的块送入Cache。<br><img src="https://s2.loli.net/2023/05/04/Qm8kKDgUG2qV3pr.png" alt="Cache原理图.png"></p><h3 id="Cache命中率"><a href="#Cache命中率" class="headerlink" title="Cache命中率"></a>Cache命中率</h3><p>h表示Cache命中率，Nc表示Cache存取次数，Nm表示主存完成的存取次数，<br>h = Nc / （Nc + Nm）</p><h3 id="Cache平均访问时间"><a href="#Cache平均访问时间" class="headerlink" title="Cache平均访问时间"></a>Cache平均访问时间</h3><p>tm未命时主存的访问时间，tc命中时Cache的访问时间<br>t = （1 - h）tm + h*tc</p><h3 id="Cache的总容量"><a href="#Cache的总容量" class="headerlink" title="Cache的总容量"></a>Cache的总容量</h3><p>存储容量和标记阵列容量（有效位、标志位、一致性维护位、替换算法控制位）</p><blockquote><p>标记阵列中有效位和标志位一定存在，一致性维护位涉及写回操作，替换算法控制位取决于Cache使用了什么替换算法<br>eg：</p></blockquote><p><img src="https://s2.loli.net/2023/05/10/92bxWvRaBXtjMeN.jpg" alt="4b7ed8f05e9e610b15628266b5ff384.jpg"></p><p>Cache的存储容量是4K个字，每个字占32位所以总容量是128K位</p><p><img src="https://s2.loli.net/2023/05/10/WoutKh9H4iOXT2j.jpg" alt="a2cc81652ee0789d1e6bc731e717433.jpg"></p><p>我们知道主存块的大小是4个字，每个字是32位，按字节编址，字块内地址有32 * 4 / 8 = 16 = 2 ^ 4，所以字块内地址有4位<br>Cache块大小和主存相同，所以Cache块的个数有4K/4 = 1K个<br>所以Cache字块占10位<br>所以贮存快标记位占18位<br>每个Cache对应一个标记项如下图：</p><p><img src="https://s2.loli.net/2023/05/10/AlmR1fqLodetVZD.jpg" alt="a48091b80032fb74f5877c9400e8842.jpg"></p><p>而有效位、标志位是必须的、题中说了直接写回，所以一致位也有，但未提及替换算法，所以不用管替换位所以标志项的位数至少是20位，有1K个Cache块，所以容量为20K<br>总容量就是128K+20K = 148K</p><h3 id="Cache的访问效率"><a href="#Cache的访问效率" class="headerlink" title="Cache的访问效率"></a>Cache的访问效率</h3><p><img src="https://s2.loli.net/2023/05/04/jdVt9GfEuYnBmhN.png" alt="Cache的访问效率.png"></p><h2 id="主存与Cache的映射"><a href="#主存与Cache的映射" class="headerlink" title="主存与Cache的映射"></a>主存与Cache的映射</h2><p>主存与Cache的映射方式共有三种：全相联映射、直接映射、组相联映射，下面依次介绍这三种</p><h3 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h3><p>主存中的任意块可以放在Cache中的任意行中<br>假设计算机的主存地址空间为256MB，按字节编址，其中Cache有8行，行长为64B<br><img src="https://s2.loli.net/2023/05/05/G4T2YRSVw3vkr5p.png" alt="全相联映射.png"><br>Cache与主存之间的信息交换是以块为单位的<br><img src="https://s2.loli.net/2023/05/05/W4njLUZy6xg2qbM.png" alt="全相联影射2.png"><br>所以我们需要有效位来指明Cache中的数据是否有效，然后需要标记为指明当前Cache中存储的信息是主存中哪个地址的信息。<br>CPU如何访存呢？首先，拿出要访问主存的地址的前22位和Cache中的所有块一一对比，并检查是否命中，若命中则根据低6位在每块中查找，若未命中则在主存中进行访存<br><img src="https://s2.loli.net/2023/05/05/uj9b4kdHDQzc1w6.png" alt="全相联映射5.png"></p><h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>每个主存块只能放在Cache的固定位置<br>没有全相联映射灵活，而且Cache中空间利用很不充分<br><img src="https://s2.loli.net/2023/05/05/WeY89RujhNc3UKA.png" alt="直接映射1.png"><br><img src="https://s2.loli.net/2023/05/05/oz2k5WY691n3d8T.png" alt="直接映射2.png"><br>我们可以优化主存块号这一项，因为主存快号末尾3位就直接指示了该地址在Cache中的存放位置，所以我们就没有必要再存储<br><img src="https://s2.loli.net/2023/05/05/KI6ivpUhdq1u2ax.png" alt="直接映射4.png"></p><h3 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h3><p>每一个主存块可以被放在特定Cache组的任意位置<br><img src="https://s2.loli.net/2023/05/05/XoCHSuMDEwVxkAh.png" alt="组相联映射.png"><br><img src="https://s2.loli.net/2023/05/05/KW3CYB4uH2MIoFS.png" alt="组相联映射2.png"><br><img src="https://s2.loli.net/2023/05/05/b69F58yEBhZnNVu.png" alt="组相联映射3.png"></p><h2 id="Cache的替换"><a href="#Cache的替换" class="headerlink" title="Cache的替换"></a>Cache的替换</h2><p>Cache的工作原理是使其保存新的数据，这样当Cache满了或则我们的旧数据占据了新数据的Cache位时这时就会需要替换策略<br>而直接映射是不需要替换策略的，因为直接映射，每个内存块能在Cache中存放的位置固定的</p><blockquote><p>常见的替换算法共三种1、最不经常使用（LFU）、2、近期最少使用（LRU）3、随机替换</p></blockquote><h3 id="最不经常使用LFU"><a href="#最不经常使用LFU" class="headerlink" title="最不经常使用LFU"></a>最不经常使用LFU</h3><blockquote><p>算法思想：我们为每一个Cache块分配一个计数器，用于记录当前Cache块被访问过几次，d当Cache满了之后，我们挑选出计数器最小的进行替换。这种替换算法看似很科学，但是却忽略了很重的时间局部性原理，因为我们是从全局考虑的，我们可以思考这种情况，曾经我们经常访问的数据，未来并不一定经常访问，当我们之前一直访问一个内存块，这时这个内存块的计数器会变的很大，但是我们后来不再使用这个内存块，但是由于这个内存块的计数器很大，几乎不会被替换出来，这就导致这个Cache块基本被浪费掉了</p></blockquote><h3 id="近期最少使用LRU"><a href="#近期最少使用LRU" class="headerlink" title="近期最少使用LRU"></a>近期最少使用LRU</h3><blockquote><p>算法思想：将一段时间内访问次数最少的行换出，我们为每一个Cache块分配一个计数器，用于记录当前块多久没有被访问过，每次需要替换时将计数器最大Cache块替换出来</p></blockquote><p>这种算法遵循了时间局部性原理，保护了刚拷贝到Cache中的新数据行，Cache的命中率比较高<br><img src="https://s2.loli.net/2023/05/05/EqTBbLaeDj4SHXz.png" alt="LRU.png"><br>我们也可以在Cache命中时，把当前计数器置为0，其余行加1</p><h3 id="随机替换"><a href="#随机替换" class="headerlink" title="随机替换"></a>随机替换</h3><blockquote><p>算法思想：顾名思义就是当Cache满了之后随机把Cache中的一个块替换出来</p></blockquote><h2 id="Cache的写操作"><a href="#Cache的写操作" class="headerlink" title="Cache的写操作"></a>Cache的写操作</h2><p>Cache中保存的是主存数据的副本，当CPU对Cache中的数据进行修改时，我们怎么保证Cache中的数据副本和主存中的数据母本的一致性呢？这就是Cache写操作需要解决的问题</p><h3 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h3><p>1、当CPU写入Cache命中时，只修改Cache中的内容而不立即写入主存，只有当这一行被替换时，才将Cache中的内容写回主存<br>2、未命中时，依然是先将主存中的内容调入Cache，然后再Cache中进行写操作，当这一行被替换时，才将Cache中的内容写回主存<br>3、这种方法可以有效减少访问主存的次数，但是存在数据不一致的风险，我们是现实时需要有一个脏位记录当前是否修改过</p><h3 id="全写法"><a href="#全写法" class="headerlink" title="全写法"></a>全写法</h3><p>1、当cache写命中时，将同时写入cache和主存，较好地维护了主存与Cache数据的一致性<br>2、当擦车未命中时，只能直接向主存中进行写入，同时又有一个问题就是是否要将修改过的主存块放入Cache？可以放也可以不放</p><h3 id="写一次法"><a href="#写一次法" class="headerlink" title="写一次法"></a>写一次法</h3><p>？这里并不是很理解写一次法是什么，为什么在第一次写命中时同时写入主存便于维护所有Cache一致性呢？<br><img src="https://s2.loli.net/2023/05/05/6wJ2zPpIHLrqDBc.png" alt="写一次法.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java接口</title>
      <link href="/2023/05/04/Java%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/05/04/Java%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是给出一些没有实现的方法定义，等到某个类要使用时，再具体实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface 类名</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">属性</span><br><span class="line">方法</span><br><span class="line">&#125;；</span><br><span class="line">class 类名 implements 接口名</span><br><span class="line">&#123;</span><br><span class="line">属性</span><br><span class="line">方法</span><br><span class="line"><span class="comment">//接口的所有抽象方法都要实现</span></span><br><span class="line">接口方法的实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中的抽象方法可以不用abstact修饰，jdk7之前接口中的所有方法都是抽象方法，而jdk8之后接口中的方法可以默认实现方法，但要用default修饰，也可以有静态方法</p><h1 id="接口存在的意义"><a href="#接口存在的意义" class="headerlink" title="接口存在的意义"></a>接口存在的意义</h1><p>在我接口时一直有一个问题，直接在用到方法的类里直接实现方法不香吗？为什么还要定义接口呢？<br>可能对于现在阶段未工作的我们答案是这样的。<br>接口的便于维护和管理<br>比如我们有三个程序员要分别实现数据库Mysql，Orcel，DB2，我们都知道数据库有连接还有关闭功能，所以我们可以定义一个接口，让三个数据库都去实现这个接口，假如我们并不定义接口，a程序员可能实现这两个方法叫A，B，b程序员实现这两个方法又叫C， D这个每个程序员实现同样一种功能的方法，名字却各不相同，我们调用起来就很难搞，而这时候接口的作用就可体现出来了。<br>接口的作用还有很多，只是初学，我们先知道这玩意时是有用的就可以了。</p><h1 id="接口的使用细节"><a href="#接口的使用细节" class="headerlink" title="接口的使用细节"></a>接口的使用细节</h1><p>1、接口不能被实例化</p><blockquote><p>因为我们知道接口本身就是一个抽象的东西，关于为什么接口不能被实例化我搜索了一下资料，我们知道java的内存分为栈区、堆区、代码、静态数据这四部分。清楚了这个之后我们先看类的实例化是一个怎样的过程，如下图，首先我们先在栈区声明了一个per，然后JVM对per进行实例化，在堆区为其开辟一段空间，用来存储这个Person对象，那么堆内存里面具体存的是那些东西呢，其实堆内存里存储的是对象的属性，我们清楚这些之后就可以对接口进行分析了，接口中的属性是用static final修饰的，而我们看下图，可以知道java中static变量是存在方法区的，不在堆区，所以就没有必要在堆区为其分配内存，而方法也是不在堆区的，所以接口没有被实例化的必要，java就规定其不能被实例化</p></blockquote><p><img src="https://s2.loli.net/2023/05/04/5xVXFUunflQHJcB.jpg" alt="20150109212141406.jpg"><br><img src="https://s2.loli.net/2023/05/04/mApveOuf6bE1R2I.png" alt="java的内存分配（运行时）.png"><br>2、接口中的方法是public的，默认用public abstract修饰我们可以将其省略<br>3、一个普通类实现接口就必须将该类中的所有方法都实现（Idea中可以使用alt + /快速完成）<br>4、抽象类实现接口可以不用实现接口中的方法<br>5、一个类可以实现多个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">I1</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I2</span></span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> <span class="title class_">I1</span>, I2</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//两个接口的方法都要实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、接口中的所有属性都是public static final<br>7、接口不能继承其他类，但是可以继承多个接口（这里的继承是和类的继承不相同的，类的继承是单一的，只能继承一个类，这里接口却可以继承多个接口）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//偷懒这里就用上面的接口了</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I3</span> <span class="keyword">extends</span> <span class="title class_">I1</span>, I2</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>8、接口的修饰符只能是public和默认的（这点和类的修饰是一样的）</p><h1 id="接口和继承对比"><a href="#接口和继承对比" class="headerlink" title="接口和继承对比"></a>接口和继承对比</h1><blockquote><p>接口学到这里我们对接口就有了一个大概轮廓的认识，接口是对抽象类的延伸，接口是对行为的抽象，java为了保护数据安全是不允许多继承的，而接口则弥补了这一种缺陷，是对单继承机制的补充。</p></blockquote><p>继承是is_a的关系，而接口时like_a的关系</p><h1 id="接口的多态"><a href="#接口的多态" class="headerlink" title="接口的多态"></a>接口的多态</h1><p>1、接口可以接收实现了接口的类，接口变量可以接收实现了该接口的对象实例<br>2、多态传递</p><blockquote><p>如果一个接口IA继承了接口IB，一个类A实现了IA，那么我们可以用IB接口类型的变量来接收类A的实例，这就相当于A也实现了接口B，所以B类型的接口也可以接收A类的实例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interface;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">IH</span> <span class="variable">Ih</span> <span class="operator">=</span> a;</span><br><span class="line">        <span class="type">IG</span> <span class="variable">Ig</span> <span class="operator">=</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IH</span>&#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IG</span> <span class="keyword">extends</span> <span class="title class_">IH</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">IG</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储系统及主存储器</title>
      <link href="/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2023/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="存储器的分类如下："><a href="#存储器的分类如下：" class="headerlink" title="存储器的分类如下："></a>存储器的分类如下：</h3><p><img src="https://s2.loli.net/2023/05/03/xLuh7DlKtoQYwB5.png" alt="分类.png"></p><h3 id="主存的分类："><a href="#主存的分类：" class="headerlink" title="主存的分类："></a>主存的分类：</h3><p>主存分为随机存储器（RAM）和静态存储器（RAM），随机存储器又分为静态RAM和动态RAM<br><img src="https://s2.loli.net/2023/05/03/xHE7XDCUaOSivkQ.png" alt="存储器的分类.png"></p><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="金字塔结构"><a href="#金字塔结构" class="headerlink" title="金字塔结构"></a>金字塔结构</h3><p><img src="https://s2.loli.net/2023/05/03/CAuS7M5EiXg4yo6.png" alt="金字塔.png"></p><h3 id="主存-辅存及主存-缓存结构"><a href="#主存-辅存及主存-缓存结构" class="headerlink" title="主存-辅存及主存-缓存结构"></a>主存-辅存及主存-缓存结构</h3><p>主存-辅存结构主要解决的问题是主存容量的问题，因为主存的容量小。<br>主存-缓存结构主要解决的是cpu速度与主存访问速度不同的问题，cpu处理速度快，而从主存中读写数据慢，我们添加一个高速缓存事先存在缓存中，这样可以提高速度<br><img src="https://s2.loli.net/2023/05/03/kAQgxL5j2tvNJ93.png" alt="存储层次.png"></p><h2 id="存储器的技术指标"><a href="#存储器的技术指标" class="headerlink" title="存储器的技术指标"></a>存储器的技术指标</h2><p>存储容量：在一个存储器中可以容纳存储单元的个数 单位字或字节数<br>存取时间：从接收到读写指令开始到完成一次存取操作的时间 ns<br>存取周期：连续两次访问存储器的最小时间间隔 ns<br>存储器带宽：单位时间里存储器所取信息量 位/s， 字节/秒<br>存取周期略大于存取时间</p><h1 id="静态存储器SRAM"><a href="#静态存储器SRAM" class="headerlink" title="静态存储器SRAM"></a>静态存储器SRAM</h1><p>1、地址译码器：控制选择存储矩阵中的哪一个存储单元。地址线有M根，就有2^M个存储单元<br>2、存储矩阵：内包含若干存储单元<br>3、控制电路：控制电路是否工作、以及工作状态下是进行读操作还是进行写操作<br>4、存储容量=存储单元个数*存储字长（可能有人要问存储字长是什么？和机器字长的关系是什么呢？）</p><blockquote><p>先说一下字长的概念：<br>（1）、存储字长：一个存储单元中二进制代码的位数<br>（2）、机器字长：cpu进行一次整数运算所能处理的二进制位数（和ALU的输入端位数直接相关，而ALU的数据来源又是寄存器和内部数据总线）<br>通常机器字长是存储字长的整数倍<br>（3）、指令字长：一条指令的总长度（可能会发生改变）</p></blockquote><p><img src="https://s2.loli.net/2023/05/03/OHmLRBKCseoYXq6.png" alt="存储器的基本结构.png"></p><h2 id="下面是基本的静态存储元阵列："><a href="#下面是基本的静态存储元阵列：" class="headerlink" title="下面是基本的静态存储元阵列："></a>下面是基本的静态存储元阵列：</h2><p>1个存储元用来存储一个二进制位的信息，对应为下图中的一个小方块<br><img src="https://s2.loli.net/2023/05/03/kfHaQjTBibtNhM1.png" alt="基本的静态存储元阵列.png"></p><h2 id="SRAM的记忆原理"><a href="#SRAM的记忆原理" class="headerlink" title="SRAM的记忆原理"></a>SRAM的记忆原理</h2><p>SRAM是用一个锁存器（触发器）来作为存储单元的<br>我们可以看下图给选择线一个低电平使其工作，假设这时我们想要写入数据，我们给数据入一个低电平，这时通过第一个与非门的信号为低电平，通过1号或门的信号为高电平而通过二号或门的电信号为高电平，也会使通过1号或门的电信号为高电平，阻止数据出这样相互耦合的电路使信息保存稳定，只要不断电就能无限期保存</p><p><img src="https://s2.loli.net/2023/05/03/l5WUc3zfijKCbu7.png" alt="静态RAM的记忆原理.png"></p><h2 id="两种译码方式的RAM"><a href="#两种译码方式的RAM" class="headerlink" title="两种译码方式的RAM"></a>两种译码方式的RAM</h2><h3 id="单译码方式的RAM"><a href="#单译码方式的RAM" class="headerlink" title="单译码方式的RAM"></a>单译码方式的RAM</h3><p>1、特点：只用一个译码器选中存储单元中的各位<br>2、优点：结构简单，存取速度快，适用于小容量<br>3、缺点：外围电路多、成本昂贵<br><img src="https://s2.loli.net/2023/05/03/PwYqxm7lK83dtL2.png" alt="单译码方式的RAM.png"></p><h3 id="双译码方式的RAM"><a href="#双译码方式的RAM" class="headerlink" title="双译码方式的RAM"></a>双译码方式的RAM</h3><p>目前的SRAM多采用双译码方式，为了组织更大的存储量。<br>所谓双译码，就是采用而二级译码将地址分为两部分（我们用x向和y向表示），我们先对x、y分别译码，然后再在存储阵列中进行二次译码。</p><blockquote><p>其实就是第一次译码确实x，y然后根据坐标再确定具体的位置<br><img src="https://s2.loli.net/2023/05/03/IWCElgavd4k13cx.png" alt="双译码方式的RAM.png"></p></blockquote><h3 id="两种译码方式的比较"><a href="#两种译码方式的比较" class="headerlink" title="两种译码方式的比较"></a>两种译码方式的比较</h3><p>这里我们通过一个具体的例子来看<br><img src="https://s2.loli.net/2023/05/03/QqxnEfSIzaNe65A.png" alt="单译码双译码的比较.png"></p><h3 id="SRANM的读写周期"><a href="#SRANM的读写周期" class="headerlink" title="SRANM的读写周期"></a>SRANM的读写周期</h3><h4 id="读周期"><a href="#读周期" class="headerlink" title="读周期"></a>读周期</h4><p>1、地址线先有效<br>2、待地址线选中存储单元后片选线和读出信号开始工作<br>3、等到片选线和读出信号都恢复高电平后地址线才恢复<br><img src="https://s2.loli.net/2023/05/03/wIXvjO1gkPp9ixl.png" alt="屏幕截图 2023-05-03 172344.png"></p><h3 id="写周期"><a href="#写周期" class="headerlink" title="写周期"></a>写周期</h3><p>1、地址线先有效<br>2、然后片选线有效，<br>3、写命令有效<br>4、撤销写命令<br>5、片选线维持的时间也比读周期长<br><img src="https://s2.loli.net/2023/05/03/CH4uITSwV3hqJME.png" alt="屏幕截图 2023-05-03 172352.png"></p><h1 id="动态存储器DRAM"><a href="#动态存储器DRAM" class="headerlink" title="动态存储器DRAM"></a>动态存储器DRAM</h1><p>DRAM存储器的存储元有一个MOS晶体管和电容器组成，MOS晶体管的作用是作为开关，存储信息是通过电容器上的电荷量体现的</p><h2 id="DRAM的读写过程"><a href="#DRAM的读写过程" class="headerlink" title="DRAM的读写过程"></a>DRAM的读写过程</h2><h3 id="写0和写1"><a href="#写0和写1" class="headerlink" title="写0和写1"></a>写0和写1</h3><p>写1：输出缓冲器、刷新缓冲器关闭、输入缓冲器打开，输入数据Din = 1送到存储元位线上，行线为高，MOS管被打开，这样电容就充电，表示存储了1<br>写0：输出缓冲器、刷新缓冲器关闭、输入缓冲器打开，输入数据Din = 0送到存储元位线上，行线为低，MOS管被打开，这样电容就放电，表示存储了0<br><img src="https://s2.loli.net/2023/05/03/6PkEAF3CdiTUrsl.png"></p><h3 id="读出过程"><a href="#读出过程" class="headerlink" title="读出过程"></a>读出过程</h3><p>读1：输入缓冲器、刷新缓冲器关闭、输出缓冲器打开，行线为高，MOS管打开，电容上存储的1被送进Dout<br>刷新：输入缓冲器关闭、刷新缓冲器打开、输出缓冲器打开，行线为高，MOS管打开，读出数据Dout经过刷新缓冲器被送到位线上，经MOS管写入电容上。<br><img src="https://s2.loli.net/2023/05/03/RPJUW9FE7ZGM8DH.png" alt="DRAM刷新.png"></p><h2 id="DRAM的逻辑结构"><a href="#DRAM的逻辑结构" class="headerlink" title="DRAM的逻辑结构"></a>DRAM的逻辑结构</h2><p>1、两个电源线Vcc、两个地线，还有一个空脚线NC<br>2、地址线只有10根而我们是1M的存储器，这里是不是很奇怪？因为这里我们用的是分时传送见下<br><img src="https://s2.loli.net/2023/05/03/N1HTgxsKnLFbEa4.png" alt="管脚图.png"><br>1、与SRAM不同我们增加了行地址锁存器和列地址锁存器，因为我们DRAM存储器的容量很大，地址线的宽度要相应增加，这会导致芯片引脚数增加，所以为了避免引脚数太多，这里我们选择的是分时传送，地址线的总宽度是10位，先送A0<del>A9，由RAS打入行锁存器，再送A10</del>A19，有CAS打入列锁存器<br>2、与SRAM不同我们增加了刷新计数器和控制电路。DRAM读出之后必须要刷新，未读写的存储元也要定期刷新，并且要按行刷新，刷新操作是与读写操作交替进行的，所以这里用了二选一数据选择器来提供刷新和读写操作</p><p><img src="https://s2.loli.net/2023/05/03/RvTQMn9WVlIxZjy.png" alt="DRAM结构图.png"></p><h2 id="DRAM的读写周期"><a href="#DRAM的读写周期" class="headerlink" title="DRAM的读写周期"></a>DRAM的读写周期</h2><p><img src="https://s2.loli.net/2023/05/03/MyjLOPufCcUzaHx.png" alt="DRAM读周期.png"><br><img src="https://s2.loli.net/2023/05/03/Tjwadnlz2LFOtiX.png" alt="DRAM写周期.png"></p><h2 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h2><p>1、刷新操作和读操作类似只是不向外输出<br>2、按行定期刷新<br>3、刷新方式有两种，集中式和分布式</p><h3 id="集中式刷新"><a href="#集中式刷新" class="headerlink" title="集中式刷新"></a>集中式刷新</h3><p>DRAM所有行在每一个刷新周期中都被集中刷新，对正常的读写周期不会产生影响<br>但是死时间时间过长<br><img src="https://s2.loli.net/2023/05/03/CgzRm6OaKkuN3YM.png" alt="集中式刷新.png"></p><h3 id="分散式刷新"><a href="#分散式刷新" class="headerlink" title="分散式刷新"></a>分散式刷新</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>将每一行的刷新分散到每个存取周期中<br>增长了存取周期<br>刷新过于频繁<br><img src="https://s2.loli.net/2023/05/03/s4aKltA17WJFywo.png" alt="分布式刷新1.png"></p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>两毫米内分散地把128行刷新一次，没有死时间<br><img src="https://s2.loli.net/2023/05/03/gd7W3BwRmoQvIhx.png" alt="分布式刷新2.png"></p><h2 id="DRAM和SRAM的比较"><a href="#DRAM和SRAM的比较" class="headerlink" title="DRAM和SRAM的比较"></a>DRAM和SRAM的比较</h2><h1 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h1><h2 id="ROM分类"><a href="#ROM分类" class="headerlink" title="ROM分类"></a>ROM分类</h2><p>ROM分为掩膜ROM、一次可编程ROM、光擦可编程ROM、电擦可编程ROM<br><img src="https://s2.loli.net/2023/05/03/3w9FsZeO8Q4UnPY.png" alt="ROM分类.png"></p><h2 id="MROM"><a href="#MROM" class="headerlink" title="MROM"></a>MROM</h2><p>1、存储内容固定的ROM、由掩膜工艺一次性制成<br>2、一旦制成无法改变<br>3、下图中绿色表示存储1，黄色代表存储0，在出厂时就已经确定<br><img src="https://s2.loli.net/2023/05/03/U7MWCy2pf6KL5qh.png" alt="MROM.png"></p><h2 id="PROM"><a href="#PROM" class="headerlink" title="PROM"></a>PROM</h2><p>PROM只能进行一次性的写入，出场时全为1或0，可根据自己的需要修改，但修改是不可逆的</p><h2 id="EPROM"><a href="#EPROM" class="headerlink" title="EPROM"></a>EPROM</h2><p><img src="https://s2.loli.net/2023/05/03/9yoTPQWRq1A7xNp.png" alt="EPROM.png"><br>1、可进行多次编程<br>2、悬空的没有引出线称为浮空栅，G为控制栅<br>3、存储信息是根据浮空栅上有没有电子来确定的，浮空栅上有电子，存储信息为0，浮空栅上没有电子存储信息为1</p><h2 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h2><p><img src="https://s2.loli.net/2023/05/03/wqgNSd9WzrVDb2h.png" alt="EEPROM.png"></p><h1 id="存储器容量扩展"><a href="#存储器容量扩展" class="headerlink" title="存储器容量扩展"></a>存储器容量扩展</h1><h2 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h2><p>只加长存储单元的字长，不增加存储单元的数量<br>数据线单独链接，地址线还有片选线、读写控制线连接在一起<br><img src="https://s2.loli.net/2023/05/03/Zk7dWBqlj8Se4ct.png" alt="位扩展.png"></p><h2 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h2><p>仅在字数方向扩展，位数不变</p><blockquote><p>eg4片16K<em>8位芯片扩展成64K</em>8位芯片</p></blockquote><p><img src="https://s2.loli.net/2023/05/03/5EzwoMeuVKYChLW.png" alt="字扩展.png"></p><h2 id="字位同时扩展"><a href="#字位同时扩展" class="headerlink" title="字位同时扩展"></a>字位同时扩展</h2><p><img src="https://s2.loli.net/2023/05/03/qdmUelVW1gnL9kz.png" alt="字位同时扩展.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内部类</title>
      <link href="/2023/05/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/05/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><blockquote><h4 id="一个类的内部又完整的嵌套了另一个类结构，被嵌套的类就被我们称为内部类，嵌套内部类的类被我们称为外部类"><a href="#一个类的内部又完整的嵌套了另一个类结构，被嵌套的类就被我们称为内部类，嵌套内部类的类被我们称为外部类" class="headerlink" title="一个类的内部又完整的嵌套了另一个类结构，被嵌套的类就被我们称为内部类，嵌套内部类的类被我们称为外部类"></a>一个类的内部又完整的嵌套了另一个类结构，被嵌套的类就被我们称为内部类，嵌套内部类的类被我们称为外部类</h4></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//内部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部其他类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">c1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h4><h5 id="1、定义在外部类局部位置上（比如方法内）"><a href="#1、定义在外部类局部位置上（比如方法内）" class="headerlink" title="1、定义在外部类局部位置上（比如方法内）"></a>1、定义在外部类局部位置上（比如方法内）</h5><h5 id="（1）局部内部类（有类名）"><a href="#（1）局部内部类（有类名）" class="headerlink" title="（1）局部内部类（有类名）"></a>（1）局部内部类（有类名）</h5><h2 id="（2）匿名内部类（没有类名）"><a href="#（2）匿名内部类（没有类名）" class="headerlink" title="（2）匿名内部类（没有类名）"></a>（2）匿名内部类（没有类名）</h2><h5 id="2、定义在外部类的成员位置上"><a href="#2、定义在外部类的成员位置上" class="headerlink" title="2、定义在外部类的成员位置上"></a>2、定义在外部类的成员位置上</h5><h5 id="（1）成员内部类（没用static修饰）"><a href="#（1）成员内部类（没用static修饰）" class="headerlink" title="（1）成员内部类（没用static修饰）"></a>（1）成员内部类（没用static修饰）</h5><h5 id="（2）静态内部类（使用static修饰）"><a href="#（2）静态内部类（使用static修饰）" class="headerlink" title="（2）静态内部类（使用static修饰）"></a>（2）静态内部类（使用static修饰）</h5><h1 id="1、局部内部类"><a href="#1、局部内部类" class="headerlink" title="1、局部内部类"></a>1、局部内部类</h1><blockquote><p>1、局部内部类是定义在外部类的方法中的<br>2、并且局部内部类可以访问外部类的所有成员包括私有的，访问的方法是直接访问，外部类在方法中可以创建内部类的对象，然后通过内部类的对象去调用其方法<br>3、不能添加访问修饰符，和局部变量一样，可以用final来修饰<br>4、作用域只在局部类的方法体内<br>5、外部其他类不能访问局部内部类（因为局部内部类的地位是一个局部变量）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Outer02</span> <span class="variable">outer02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer02</span>();</span><br><span class="line">        outer02.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer02</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//私有方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//局部内部类通常定义在外部类的方法中</span></span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner02</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//局部内部类可以访问外部类的所有成员，包含私有的</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                m2();</span><br><span class="line">                System.out.println(<span class="string">&quot;n1 = &quot;</span> + n1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Inner02</span> <span class="variable">inner02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner02</span>();</span><br><span class="line">        inner02.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>6、如果外部类和内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员可以使用（外部类名.this.成员）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out02.<span class="built_in">this</span>.n2</span><br></pre></td></tr></table></figure><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><blockquote><p>1、本质是类<br>2、内部类, 但实际是有名字的，只不过用完之后会立即被销毁<br>3、该类是没有名字<br>4、同时还是一个对象</p></blockquote><blockquote><h3 id="匿名内部类创建之后，会立马实例化出来，然后这个匿名类内部类就不能再被使用了，但实例化出来的对象是可以反复调用的"><a href="#匿名内部类创建之后，会立马实例化出来，然后这个匿名类内部类就不能再被使用了，但实例化出来的对象是可以反复调用的" class="headerlink" title="匿名内部类创建之后，会立马实例化出来，然后这个匿名类内部类就不能再被使用了，但实例化出来的对象是可以反复调用的"></a>匿名内部类创建之后，会立马实例化出来，然后这个匿名类内部类就不能再被使用了，但实例化出来的对象是可以反复调用的</h3></blockquote><h3 id="基于接口的匿名内部类使用"><a href="#基于接口的匿名内部类使用" class="headerlink" title="基于接口的匿名内部类使用"></a>基于接口的匿名内部类使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Outer04</span> <span class="variable">outer04</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer04</span>();</span><br><span class="line">        outer04.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer04</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//基于接口的匿名内部类</span></span><br><span class="line">        <span class="comment">//tiger的编译类型？IA</span></span><br><span class="line">        <span class="comment">//tiger的运行类型？就是匿名内部类</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            底层是</span></span><br><span class="line"><span class="comment">            class XXXX implements IA</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                public void cry()</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;老虎叫唤...&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老虎叫唤...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;tiger的运行类型 = &quot;</span> + tiger.getClass());</span><br><span class="line">        tiger.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2023.cnblogs.com/blog/3012367/202304/3012367-20230427103811618-2065452851.png" alt="image"></p><h3 id="基于类的匿名内部类"><a href="#基于类的匿名内部类" class="headerlink" title="基于类的匿名内部类"></a>基于类的匿名内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String []args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Outer04</span> <span class="variable">outer04</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer04</span>();</span><br><span class="line">        outer04.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer04</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//基于接口的匿名内部类</span></span><br><span class="line">        <span class="comment">//tiger的编译类型？IA</span></span><br><span class="line">        <span class="comment">//tiger的运行类型？就是匿名内部类</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            底层是</span></span><br><span class="line"><span class="comment">            class XXXX implements IA</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                public void cry()</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    System.out.println(&quot;老虎叫唤...&quot;);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老虎叫唤...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;tiger的运行类型 = &quot;</span> + tiger.getClass());</span><br><span class="line">        tiger.cry();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常new一个对象</span></span><br><span class="line">        <span class="type">Father</span> <span class="variable">father1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;father1对象的运行类型是=&quot;</span> + father1.getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了test方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;father对象的运行类型=&quot;</span> + father.getClass());</span><br><span class="line">        father.test();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;小狗吃骨头&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        animal.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img2023.cnblogs.com/blog/3012367/202304/3012367-20230427105440700-1340056105.png" alt="image"></p><h2 id="匿名内部类的使用细节"><a href="#匿名内部类的使用细节" class="headerlink" title="匿名内部类的使用细节"></a>匿名内部类的使用细节</h2><blockquote><h3 id="匿名内部类的定义比较特殊，本身是一个类同时还是一个对象"><a href="#匿名内部类的定义比较特殊，本身是一个类同时还是一个对象" class="headerlink" title="匿名内部类的定义比较特殊，本身是一个类同时还是一个对象"></a>匿名内部类的定义比较特殊，本身是一个类同时还是一个对象</h3></blockquote><h4 id="先定义一个匿名内部类，接收之后，再用生成的对象"><a href="#先定义一个匿名内部类，接收之后，再用生成的对象" class="headerlink" title="先定义一个匿名内部类，接收之后，再用生成的对象"></a>先定义一个匿名内部类，接收之后，再用生成的对象</h4><p><img src="https://img2023.cnblogs.com/blog/3012367/202304/3012367-20230427110459864-2046254694.png" alt="image"></p><h4 id="不接收直接调用"><a href="#不接收直接调用" class="headerlink" title="不接收直接调用"></a>不接收直接调用</h4><p><img src="https://img2023.cnblogs.com/blog/3012367/202304/3012367-20230427110559871-1909676952.png" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClassDetail</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Outer05</span> <span class="variable">outer05</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer05</span>();</span><br><span class="line">        outer05.f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer05</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了hi&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        person.hi();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//也可以直接调用</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了hi&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.hi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类的实践"><a href="#匿名内部类的实践" class="headerlink" title="匿名内部类的实践"></a>匿名内部类的实践</h3><blockquote><p>匿名内部类主要用于当前类只使用一次，使用过后我们就不会再反复使用，这样我们就没有必要专门再写一个类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassExercise01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span></span><br><span class="line">    &#123;</span><br><span class="line">       f1(<span class="keyword">new</span> <span class="title class_">IL</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;这是一幅名画&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(IL il)</span></span><br><span class="line">    &#123;</span><br><span class="line">        il.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IL</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClassExercise02</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CellPhone cellPhone = <span class="keyword">new</span> <span class="built_in">CellPhone</span>();</span><br><span class="line">        cellPhone.<span class="built_in">alarmclock</span>(<span class="keyword">new</span> <span class="built_in">Bell</span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">ring</span>() &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;懒猪起床了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cellPhone.<span class="built_in">alarmclock</span>(<span class="keyword">new</span> <span class="built_in">Bell</span>() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="type">void</span> <span class="built_in">ring</span>() &#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;小伙伴们上课&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Bell</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ring</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CellPhone</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">alarmclock</span><span class="params">(Bell bell)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        bell.<span class="built_in">ring</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>1、成员内部类是定义在外部类的成员位置，并且没有static修饰。<br>2、成员内部类可以直接访问外部类的所有成员，包括私有成员。<br>3、外部类访问内部类，就是直接创建一个内部类然后通过类进行访问。<br>4、我们可以用public、private、protected去修饰，因为它本身就是一个成员<br>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemberInnerClass</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        Outer08 outer08 = <span class="keyword">new</span> <span class="built_in">Outer08</span>();</span><br><span class="line">        outer08.<span class="built_in">t1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer08</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner08</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;n1 = &quot;</span> + n1 + <span class="string">&quot; name = &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">t1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner08 inner08 = <span class="keyword">new</span> <span class="built_in">Inner08</span>();</span><br><span class="line">        inner08.<span class="built_in">say</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>外部其他类使用成员内部类的两种方式<br>1、<br><img src="https://img2023.cnblogs.com/blog/3012367/202305/3012367-20230501134604393-795927860.png" alt="image"><br>2、<br><img src="https://img2023.cnblogs.com/blog/3012367/202305/3012367-20230501134840435-574862165.png" alt="image"></p></blockquote><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>比上个内部类多了一个static修饰符<br>1、静态内部类，在外部类的成员位置，有static修饰<br>2、可以访问外部类的所有静态成员，非静态不能访问<br>3、作用域为整个类体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer10</span> <span class="variable">outer10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer10</span>();</span><br><span class="line">        outer10.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer10</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="comment">//静态内部类，在外部类的成员位置，有static修饰</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以访问外部类的所有静态成员，非静态不能访问</span></span><br><span class="line">    <span class="comment">//作用域为整个类体</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner10</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner10</span> <span class="variable">inner10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner10</span>();</span><br><span class="line">        inner10.say();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专业课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 823 (Div. 2)C</title>
      <link href="/2023/05/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/05/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Minimum-Notation"><a href="#C-Minimum-Notation" class="headerlink" title="C. Minimum Notation"></a><a href="https://codeforces.com/problemset/problem/1730/C" title="C. Minimum Notation">C. Minimum Notation</a></h1><p>思路：我们可以进行的操作时将一个位置的数删除然后在任意位置处添加一个比当前数大1并且小于9的数，所以我们的操作只会让一个数变大，我们统计一个最大值的后缀，贪心的考虑如果当前数的后面有比他小的数的话，我们就需要让这个小的数往前走才能使字典序变小，如果当前值小于&lt;= 后缀的最小值，说明这个数后面的所有数往前移动都不能使字典序变得更小，所以我们统计完后缀后，从前往后扫一遍，用multiset维护以下，即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> c[N], suf[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, c + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> mn = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">strlen</span>(c + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = c[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(num &lt; mn)mn = num;</span><br><span class="line">suf[i] = mn;</span><br><span class="line">&#125; </span><br><span class="line">multiset&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = c[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(num &lt;= suf[i])s.<span class="built_in">insert</span>(num);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">9</span>)s.<span class="built_in">insert</span>(<span class="number">9</span>);</span><br><span class="line"><span class="keyword">else</span>s.<span class="built_in">insert</span>(<span class="built_in">min</span>(num + <span class="number">1</span>, <span class="number">9</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : s)cout &lt;&lt; x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;1.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="type">int</span> t;cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t --)<span class="built_in">run</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> codeforces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 思维 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
